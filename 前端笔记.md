#前端笔记


[TOC]



## es6的知识点
### map的使用
let map  =new Map();
map.set(key,value);修改
map.get(key);来获取key所对应的值
map.add(key,value);添加

**map的作用**：

map里边是可以把对象作为key来进行存储的。

### weakMap的使用
let weakMap=new weakMap();
这个方法和map比较相似

**与Map的不同点：**
首先：weakMap的key值必须是对象
其次：是弱引用类型。强引用类型，就是把对象直接赋值给变量，这种是强引用。
*强引用和弱引用的区别：*
强引用是当我们把引用销毁了例如把变量等于空，那么变量就不会只指向对象，当对象没有指向的引用，则对象就会被垃圾回收器清空。
强引用就是即使这个引用指向对象，但是已经失去了被调用的可能，那么垃圾回收器也不会回收。
但是弱引用刚好相反，当对象失去了调用的可能，那么垃圾回收器不会考虑弱类用，而是直接进行回收。
这里说的不是很懂，其实还需要一些例子？？？？

### class 类的使用
    这样有利于结构更清晰

    calss  类{
        constructor(){//构造函数,对象初始化时执行的函数
            
        }
        
        fn(){
        
        }
    }


###extends 和 super的使用
继承：extends    super是字类继承父类使用的关键字
子类只要是继承了父类，那么子类不需要写构造函数，会自动调用父类的构造函数。但是，如果子类想要有自己的构造函数，那么子类必须用super调用父类的构造函数，才可以，否则会报错，同时子类在自己的构造函数里边，可以多一些操作。如下例子：
例子如下：

    class Person{
        constructor(name){
            this.name=name;
        }
    }
    class student extends Person{
        constructor(name,type){
            super(name);//必须调用父类的构造函数，否则报错
            this.type=type;//这个是自己添加的操作
        }
    }


###同步与异步的操作

定时器，setInterval是异步编程，但是定时器是要等所有的主线程完成操作之后，定时器才会去执行，如果有主线程的任务在执行，则定时器会立即停止。

####promise用来解决的异步编程的问题
首先promise有3种状态：pending(表示还未执行里边代码),resolved(成功执行了代码),rejected(执行代码失败)，resolve和reject这两个是方法，表示成功和失败需要执行的方法。如下是代码，

     let p1=new Promise((resolve,reject)=>{
            setTimeout(function(){
                console.log(1);
            },1000);
            resolve();//如果执行了这个函数，则状态变成了resolved
        });
        console.log(p1);
        

如果我们不写resolve和reject这个两个方法，则Promise里边的代码还是会执行，但是我们不知道是执行成功了还是失败了。

![image_1cs85lemjgjt1puv1t493om1glq9.png-12.9kB][1]


  
####promise中的then方法

then方法是的结构是这样的：
promise对象.then(()=>{},()=>{});里面是两个方法，第一个方法是当promise的状态变成resolved时执行，第二个方法是promise中的状态是rejected时执行。

    then(()={},（）=>{}).then(()=>{},()=>{}).then(()=>{},()=>{})
这是then的链式执行步骤，then方法不管是执行的是resolve还是reject，都会返回一个resolve的新的promise对象，也就是说这个返回的promise对象的状态默认是resolve成功的，所以只会调用后边then方法中的第一函数。从而导致后边的then方法里边的第二个方法（也就是reject状态时执行的方法）不能得到执行。如果要想后边的then 方法中能执行到第二个方法，那么我们需要在then方法中返回一个新的promise时并且执行reject方法**（return new Promise((resolve,reject)=>{reject();}）**，后面才会执行then方法中的第二个方法。不过后边的一个then方法执行完第二个方法后，如果我们不再编写新的Promis对象返回，那么会自动返回一个新的promise对象状态依然是resolve。
如代码分析：

        let p1=new Promise((resolve,reject)=>{
            setTimeout(function(){
                console.log(1);
            },1000);
            reject();//因为这里执行的是reject，
            //所以后边的第一个then执行的是第二个函数
        });
        let p2=p1.then(()=>{
            console.log("成功1");
        },()=>{
            console.log("失败1");
            //第二步执行这里，然后返回一个新的Promise对象状态为resolve
        });
        let p3=p2.then(()=>{
            console.log("成功2");
            //第三步是执行这里，如果要想第四步执行then的第二个函数，
            //需自己更改返回的Promise对象，如下：
            return Promise((resolve,reject)=>{
                reject();//默认状态下是返回resolve
            });
        },()=>{
            console.log("失败2");
        });
        let p4=p3.then(()=>{
            console.log("成功3");
        },()=>{
            console.log("失败3");
        });
        p4.then(()=>{
            console.log("成功4");
        },()=>{
            console.log("失败4");
        });
        
这段代码执行的结果如下图：
![image_1cs881fh41to3seevjo13ac1pv0m.png-7.2kB][2]


 **注意** return Promise.reject()是下边函数的简化
 
    return Promise((resolve,reject)=>{
         reject();
    });
                             
   
   
####promise 和 then  和 catch之间的关系
  
  promise 对象中如过没有reject或者是resovle那么则不会去执行then里边的函数。
  
  catch和then是一样的，都会返回一个resovled状态的Promise对象。
  
**catch的失效**
  catch如果要想捕获then方法里边的错误，必须是then方法的第二个方法抛出reject错误后，后边没有任何then方法有第二个方法才可以，否则then的第二个方法会接收这个错误，那么这个错误就到此结束了，不会到达catch，如果所有抛出的错误都有后边的then方法来接收（指的是第二个方法），那么catch就失去了作用。

**catch适合的场景**  
catch只适合一个then链接里边只有一个then里边写了两个方法，其中一个方法是抛出错误的方法，后边的then都只有一个方法(后边就没有接收抛出错误的then了)那么catch才能接收到这个错误。

**then之间的跳跃**
如果一个then的第二个方法抛出了reject，那么后边的then就必须有第二个方法才能执行，如中间的then没有第二个方法，就会被跳过，直接跳到有第二个方法的then。

####promise中值的传递和Promise.all 以及 Promise.race
resolve(参数);
resject(参数);
那么接收的then方法里边的方法的实参就是接收这个值的。

这个方法表示的是p1和p2都成功完成了，也就是都调用了resolve。并且把返回的值组成一个数组传递给data。再执行then方法里边的内容
Promise.all([p1,p2]).then((data)=>{
},(err)=>{});

这个方法与上边的方法类似，区别是只要数组里边的promise对象只要有一个完成了，就会执行then里边的方法。
Promise.race([p1,p2]).then(data=>{},err=>{});

####async await的使用 try...catch...的用法

    async function fn(){
            try{
                
                let g=await getDate();
                console.log(g);
                let g3=await getDate2();
                let g1=await getDate1();
                console.log(g1);
                
            }catch(err){
                console.log(err);
            }
        }
        fn();
   
async需要写在一个函数的前面，函数里边的方法执行前加上一个await。
这么写是看上去代码像同步的，但是里面的代码的执行都是异步的。

try...catch(err){},是用来捕获async和await异步方式的，如果遇到异常(reject)那么异常后边的代码都是不执行的，异常前边的代码已经执行了未结束的都可以执行完毕。

##Node

###node的基础命令
repl命令也就是cli命令窗口
.exit 退出窗口
.save  当前结果保存起来，可以把文件再打开看的。
.clear 清除命令行
.load xx.js 就是把xx.js里边的命令进行执行。

**注意:**  在repl命令窗口里边，经常会看到undefined，这个是repl命令对当前执行命令的输出，一般是用于计算。如果我们不是用于计算就会输出undefined。
        
        
####**环境变量**：
在windwos中cmd窗口下输入set 命令可以查看所有的环境变量
set  环境变量名=值，这样可以设置环境变量。
echo %环境变量%     这样可以获取环境变量的值
echo 是windwos的输出命令


####**global全局变量：**

**console**

console.log  console.error  console.log.info
浏览器输出或者是repl输出

**__dirname**
输出当前目录的地址

**__filename** 
输出当前文件的物理位置

**事件循环**
nodejs中，如果存在同步和异步的任务，主线线程会先执行所有的同步任务，在执行同步任务时会把所有的异步任务放入异步任务队列中，当同步任务执行完毕之后，再去执行异步任务。

图：
![2.png-60.8kB][3]


*异步任务的优先顺序*：

定时器---->io流(ajax等)---->check(setImmid..这两个)---->关闭数据库链接或者是关闭callback的链接---->在判断是否有异步任务，这里是一个循环，直到所有的异步任务完成位置。
异步虽然有这个优先顺序的，异步操作不会等结果结果执行完，而是这个执行了，下一个也会跟着执行，互不影响。但是每次完了后都会去判断是否还有要执行的异步操作，不断的这么循环并且速度非常快，直到所有的异步都执行完毕才会退出程序。

*io流也有自己的执行顺序*：


就是io流自己也有一个闭环，就是当网络请求时会等待网络返回给数据，所以会等着网络返回的数据，但是会有一个时间的限制，超过这个时间如果数据还没有返回则会执行下一个异步处理。

更详细的图片：
![3.png-99.7kB][4]


**宏任务与微任务：**

只有主线程里边才有宏任务和微任务，主线程也就是同步队列里边。宏任务先执行，微任务后执行。
宏任务：script 体，setTimout setInterval
微任务：Promise中的then方法  Promise.nextTick等
先同步，同步分宏微任务完了后，再异步，异步被推倒主线程后再分宏微观任务。
**注意：**
new  Promise是宏任务，但是then方法是微任务。

这个理解起来比较困难，所以举个栗子：

####**总结事件循环**####
(主线程)判断同步还是异步，同步继续走主线程，异步放入eventLoop里边--->(主线程)同步里先执行宏任务再执行微任务--->（主线程）把同步任务都执行完毕后--->(主线程)会从eventLoop中会把异步任务也推进到主线程--->(主线程)分辨是宏任务还是微任务--->宏任务(如果宏任务是异步方法，则只是把异步方法放入eventLoop等待下一次从eventLoop中推进。微任务也一样)先执行，微任务后执行。
**注意：**
事件循环中，我们把异步操作放入eventLoop中，我们从eventLoop中任务推到进程里边时，只是把异步操作的内容推进去执行，内容里边有异步操作和其他非异步操作，非异步操作会直接执行完，异步操作会再次放入eventLoop中，这样形成循环直到所有的异步操作都被执行完毕。

###模块化###
1，一个文件是一个模块
2，文件加载是同步模式
3，exports 导出，require（）导入

require(模块id/模块路径);

commonjs模块，不是浏览器的模块，是适用于后端和桌面应用程序的模块。


###**内置对象**###

####AMD、CMD 和COMMONJS 和REQUIREJS关系####
commonjs是一套的规范，这套规范有很多的内容。而amd和cmd模块实现了这套规范的一部分，而requirejs是具体的执行模块是属于amd和cmd规范的。

####module模块：####
每个模块都内置了一个module模块对象。
每个模块中都有一个exports对象

属性：
module.id  是这个模块的id，默认id是这个当前文件的绝对路径
module.filename:当前文件路径
module.parent :这个是表示这个模块被加载到了某个模块里边，某个模块就是它的父模块，parent属性的内容是父模块的内容。
module.children：表示的是这个模块里边有一个加载的子模块，children属性里边的内容就是那个子模块的内容。
module.loaded:表示当前模块是否加载完成了
module.paths:路径，之后会具体说到。

**module中的require和exports**：

require（）其实是module.require ,只是当前模块中所以可以省略掉module而已。

exports：module.exprots

**module.exports 和 exports的关系**
默认：exports=module.exports;

module.exprots有一个这样的属性，但是模块中又有一个exports对象，那么这两者有什么关系呢？
exprots===module.exports 这个返回的是true。这个等号是值相等，值指的是对象。

实际上：模块的返回对象是module.exports，只是exports引用了module.exports的地址。所以在不改变exports的引用地址的情况下,例如exports.a这个是给对象添加变量，其实也是给module.exports对象添加变量，所以能正常返回。
模块的返回值只有module.exports,我们会被exports.变量的操作后，会发现也能正常返回这个变量。其实这里有障眼法的，因为exports本身没有指向的对象，它指向的是module.exports的地址，所以它间接的改变了module.exports里边的值。实际上模块返回的还是module.exports，只是值被exports改变了而已。
**重点**：当exports={a:1},一旦有对象产生，那么系统会分配一个新的地址，这时exports会指向这个新对象的地址。这样就不会再执行module.exports模块了，他们之间的关系就断了。

####加载机制####

如果文件夹下边没有package.json文件，那么默认会加载（require）index.js
如果文件夹中有package.json，那么会根据package.json中的main属性来寻找。
#####设置package.json######
```
    {
        "name":"语义化"//尽量别用特殊字符，这个是必须写的，没有特别的规定
        "main":"./xxx.js" //这个是模块在加载文件夹时，在文件夹中寻找main属性对应的文件
        
    }

```

**导入文件夹模块时的流程：**
1，首先会看文件夹下边是否有package.json 如果没有则寻找index.js
2,如果存在package.json则会根据main属性所对应的路径进行读取。
3，注意：在模块加载文件夹时，首先读取的第一个文件就是判断是否存在pacage.json,如果存在则会先读取这个文件。


#####路径加载机制和非路径加载机制#####

**路径加载模式**：./ ../ 开头加载的

**非路径加载机制**：就是看加载的文件是否在node_modules文件夹中，如果在，则无需写加载的路径，直接写加载名字即可。
这种加载的实现是如下的：
首先我们的module下边是有一个path属性的，path的值为：
![image_1ct71dpe113u24lq3rp1g948179.png-5.7kB][5]


 我们会看到都是node_modules的路径，其实非路径加载机制就是循环这个node_modules的数组路径，直到根目录下的node_modules，如果其中找到了，则不会再往下寻找。如找不到则一直往下寻找，直到找到最后一个。
 另外一种理解意思：是从当前往父级递进的寻找node_modules文件夹。
 
 *问题：如果父级想访问子级别中的node_modules就不无法访问了？*
 所以为了解决这个问题
 所以会有一个全局的node_modules 是在global下的
 这个学的不好就不撰述了
 
 **内置核心模块**
 
 如果自己的模块与核心模块冲突，那么会加载内置核心模块。
 例如：fs 就是内置核心模块。
 
 **文件的寻找分成如下顺序**：
 文件-->.js->.json->node
 
#####--node中es6的操作#####

node是不支持es6的，所以我们用node进行编译的时候，会报错。

**es6的加载机制和node的加载机制是不一样的：**

导出为：export var a=1； export的导出都是对象。其实导出为：{a:1}
导入为：import {a} from "./1.js"  import ...from....语法  {a}这个是es6的结构语法，就是把导出来的对象进行解构。

export与node中的module.exports不同之处：
他们本来就是两个东西，export是可以导出多个的，如：
```
    export var a=1;
    export var arr=[];
    export.....
    //可以导出多个
```


import导入：不想用解构方法来获取导入进来的内容，那就需要用星号来表示，但是星号又不能用作变量，所以用as给星号分配一个变量。如下图：
```
    import * as objs from "./1"  //objs就是*号别名，1文件所有的导出内容都放在了objs对象里边。
    
```

**export default的使用以及export直接导出的关系**
export default 这个是表示导出的内容不需要声明直接写值，这个声明用default代替了。且一个模块只能有一个export default；
如下代码的两个对比：
```
    //之前导出是这样的
    export var a=1;
    //现在用export default
    export default 1；
```
export default 的接收也是不一样的，为如下：
```
    import v from "./1" //这个v就是接收export default导出的内容
    
```

与export直接导出的关系：
1，export的导出，export可以有多个，但是export default导出只能有一export default。
2，接收方式不一样，export可以用解构接收和“*”号全部接收，但是export default 就是正常的接收。





**如何编译es6语法？**
需要做到两个方法：
1，我们用node编译时需要带上 experimental-modules 
2,我们需要把.js文件结尾的文件改成.mjs
然后在编译：
```
    node experimental-modules 1.mjs  //.mjs也可以省略掉
```


####--event(模块)####
在node里边只有继承了event模块的类才能使用事件。
let eventEmitter=require("events");
class Person extends event{
}
let p=new Person();
那么new 出来的新对象就可以使用自定义事件了。

定义一个事件：
p.addListener("事件名",function(){
});
触发一个事件：
p.emit("事件名");

实际的案例如下分析：
```
    let EventEmitter=require("events");

    class Person extends EventEmitter{
        constructor(name){
            super();
            this.name=name;
            this.age=0;
            this.growup();
            //调用函数里边，函数里边触发自定定义函数growup
        }
        growup(){
           let timer=setInterval(()=>{
                this.age++;
                //自动执行一个事件,当自动执行这个事件时就会从自定义事件里边
                //去寻找是否有自定义的这样的事件
                this.emit("growup");
                if(this.age>=10){
                    console.log(this.name+"只能长到10岁");
                    clearInterval(timer);
                }
            },1000);
        }
    }
    let p=new Person("老胡");
    //自定义一个事件
    p.addListener("growup",function(){
        console.log(this.name+"长大了一岁");
    });


```

p.setMaxListeners(n);//用来设置最多可以是多少个监听器，默认是10个
p.eventNames();//获取监听的器的函数名字

####--process（模块)####

这个是全局对对象,这个与系统的内存、进程相关的对象。

process.argv  这个是你在node中输入的命令
***作用***：就是可以用来建设一个脚手架工具，cli命令工具等。
process.env 环境变量：能够获取当前系统的环境变量

process.exit[code]  
process.exit():是退出进程

**标准输入输出流**

输出：
process.stdout.write("xxx");//console.log("nihao")也是用这个输出的。

输入：
process.stdin.on("data",function(chunk){//当我们在控制台输入数据时，按回车键后就触发了data这个事件。
    console.log(chunk);
})

####--stream流（模块）####

 这个是个抽象接口，其实是没有实现，我们都是到具体的模块中才去实现。
 
####--buffer（模块）####
创建一个buffer
```
第一种创建：
var bf=new Buffer(4);//创建长度为4的buffer对象，buufer默认是由0填充。
8位是一个字节，2的8次方是1256，但是有一个写字符是大于256的，所以一个字节不能存储一个字符。


第二种创建：则是把别的数据转变成buffer
Buffer.from(array)
Buffer.from(stirng[,encoding])
 
``` 
 
 buffer一旦被创建则长度是固定不变的。
 
 buffer默认的显示方式16进制，但是buffer里面的计算用的是二进制。
 
 buffer比较值是否相等，bf1.equals(bf2) 。切记，这个只是比较buffer中的数据是否相等，并不是两个对象相等。
 
 **中文占用字节**
 
 不同的编码则中文占用的字节是不一样的，例如：utf8则是一个字符占用3个字节。gbk是占用2个字节。
 
####--fs（模块）####

 我们的文件系统是i/o操作，程序和外在的程序交互那么就用用流。涉及到二进制的操作就会用到流，而在node中对二进制的操作用的buffer。
 
 
```
    let fs=require("fs");
    fs.writeFile(path,data[,options],callback); //创建文件并且写入数据，但是每次写入数据都会把上一次的数据覆盖掉。
//如果地址中目录不存在，则会报错。例如："G:\d\aa\1.txt"; 比如这个路径中的aa目录根本就不存在，则创建会失败。

fs.appendFile(path,data,callback); //追加数据，默认是尾部追加

fs.readFile(path,(err,data)=>{    //读取数据，读取出来的内容默认的是buffer
})


    
    
```

**文件状态fs.stat()**

```
    fs.stat(path,function(err,status){ //读取的状态
        status.isFile() //判断是否是文件
        status.isDirectory()//判读是否是目录
    });
    fs.unlink(path,callback);删除文件
```

**目录的操作**
mkdir(path,callback) //创建目录，但是不能层级创建。
rmdir(path,callback) //不能删非空目录，也就是目录里边不能有文件。如果目录里边有空目录并不会影响删除。

**fs.watch 监听：**
fs.watchFile(path,data=>{
})
//当文件发生改变时，就会触发这个监听里边的回调方法。


监听文件或者是目录都可以
fs.wacth(path,(type,filename)=>{
})
type:分两种类型，一种是change，一种是rename   ，当文件的内容进行修改时，则type为change。当有文件新增或者是删除时，则type为rename；

filename：是对具体的文件进行的操作。


###（min项目）构件化工具的实现--简单版###

####实现的功能####
1，首先是通过在node中输入node xxx 参数  自动创建目录以及文件

-简单描述node 这个命令的作用

这里的xxx代表的是实现这个功能的js文件，就叫做myCli.js
所以在node中输入的命令为：node myCli app -i  
myCli是node执行的js文件，app是要创建的目录，-i参数表示创建默认首页文件


- 创建目录

 使用process.argv 获取了在node中输入的内容
 mkdir用来创建目录，切记创建目录时地址写全。如果目录已经存在则错误提醒。fs.exists()判断目录是否存在。
 然后在这个目录下边自动创建image、css、js目录。
如果创建成功了则提示创建成功

- 创建index文件

这个需要判断输入的命令中有没有带 -i 如带了则会创建一个index.html文件


###npm###

npm search  包名   //可以搜索包名 ，也可以到npm的官网上进行搜索查看
npm ls  //查看npm 已经安装的包
npm up 包@版本号  //表示更新包 或者npm update 包，这里的更新并不是指最新的，而是只把当前版本的功能和补丁更新到最好版本。例如：jq2.0.0 只能更新到jq2.最高.最高
npm uninstall  包 //删除
-g 表示的是全局安装

####npm中的手动创建项目和自动创建项目####

npm 清理缓存问题：npm cache clean --force

#####--package.json手动创建项目#####

package.json中：必须有name和version这两项


```

    //规定：name是指项目的名称，必须是小写且只能是一个单词，可以用-和_线。
    //{}中的属性必须都是双引号表示
    {
        "name":"one",
        "version":"2.0.1" ，
        "script":{
            "test":"echo \"nihao,hudaye\" " //这里的script是当在当前目录下，npm run test 这个命令就会执行test对应的值。为何要这么做？是因为有写命令过长，我们可以通过这种方式来简化。
            //还有在npm中 echo  是输出的意思。
        }，
        "dependencies":{    //显示当前依赖和安装的包，这个还有一个作用是：当别人从我这里依赖时，无需拷贝node_modules中的文件，而是直接拷贝package.json这个文件即可。因为用npm install  这个命令会根据当前package.json中的dependencies中的依赖进行所有安装。并且这个只会在项目里边出现，在全局安装里边是不会出现的。
            "jquery":"^3.3.1"，
            "bootstrap":"^1.1.1"
        },
        "devDependencies":{//这个是表示的是开发环境，作用是：在打包的时候不会打包这里的依赖。用npm install -D 或则是 npm install --save-dev 的方式就是这种方式的安装。
            "bable":"^6.23.0"
        }
    }
    
```

#####--npm init自动创建命令#####
npm init 会自动以当前的目录为包名
然后会有交互式的回复，自动生成。


#####--package.json和package-lock#####
package-lock是package.json安装包的一些信息的记录和描述。


####npm的发布npm更换源####
npm login //登录
npm publish //是发布,就是把当前的项目发布上去

**疑问**：之前在这里有个疑问，就是npm publish 发布到底是哪个包，其实不要有疑问，因为你在操作之前是做了npm init的操作的，那么你发布的就是这个包。

npm 更换成淘宝的地址源头,如下：
```
npm config set registry http://registry.npm.taobao.org/

```

####cli命令####
npm create -h xxx
npm是命令
create是子命令
-h是选项
选项：是内置的，例如：-v,-h
参数：是用户在执行的时候传入的数据



**全拼和简写**：
全拼：--version   简写：-v  。所以--一般表示的是全拼，而-表示的是简写。

**缩写**
例如有多个选项，例如  ....-d -r  可以写成  -dr 但是如果r带了参数则参数写在r的后边，npm  -dr 参数。如果r选项带了参数，则千万不能写称-rd  参数，因为这样是参数是给d的。

**通过看文档来判断命令的写法**

如下图所示：<>里边的表示的是参数，且还表示了参数的类型。

如下图：



![image_1ctf9r52m1h7iehvtq14vkqt6c.png-117.8kB][6]


  
  
###cLi的框架###

####commander框架####

vue的脚手架就是基于这个做出来的。

第一步：还是需要npm进行安装
第二步：require进行导入
第三步：
```
    commander.parse(process.argv); //这样后，默认情况下就会有一个-h是实现的。
    
    commander.version("版本号","-V ，--version");//这里的-V和--version是默认的，当然我们也可以改成其他的。用逗号隔开表示的是两个都是可以的。如果我们把大写的-V改成小写的-v，如：commander("1.0.0","-v,--version")。然后我们运行:node com.js -v命令后，就会在控制台输出1.0.0 
    
    commander.option(flags,desc,value) //这个是自定义选项命令的，在commander中除了版本号可以用version方法来实现外，其他的选项命令都是需要自己来定义的。而这个方法就是自定以选项的方法。例如：commander.option("-n,--name[val]","print name","huminggui");在命令行可以执行如下命令：node com.js -n "dongbinhong"   解释上边命令格式：第一个参数为选项命令，[]号表示可选参数，这个参数可以写也可以不写，如不写，默认为后面的值。如果不是[]号，而是<>号，则表示必须要写。第二参数是描述当前选项命令的。
> //其实是第三个参数可以是一个function的函数，function函数的参数是选项在命令行中输入的参数值。如：commander.options("-n,-name[val]","print name",function(val){})。如果在命令行输入 node com.js -n aa 那么function中的val参数就是aa。重点：这个function有一个return的返回值，这个返回直是真正的选项的参数值。因为用了function所以在命令行中输入的参数值为val方式输入到了函数的里边，可以直接return这个参数。function的作用其实是可以对输入进来的选项的参数值进行进一步的处理。重点2：我们添加的选项，会以对象的形式保存在commander上，如：我们添加的是username选项，添加的方法如下：commander.option("-un,--username[val]","print name","huminggui")。那么可以commander.username的方式来调用这选项命令在执行时输入的参数值。
    commander.action(function(){})  //这个是在配置好选项之后我们需要做的动作，例如：commander.action(function(){console.log("hellow,commander.username)}); 当执行命令 node com.js -un hu 时，则会输出 hellow hu

子命令：
commander.command("crateName<必选参数>","说明") //执行的时候可以是如下：node com.js createName 参数，子命令的动作和父命令是一样的。
需要注意的是：一旦有子命令，那么父命令就不存在了，需要去匹配子命令的格式。在commande()里边就是子命令匹配的格式。

描述操作：
commander.description("")

别名：
commander.alias()

使用说明：
commander.usage()



```
**如果遇到问题参考**：
这一步骤主要是注意事项，就是在文件里边必须写上commander.parse(process.argv);且最好是放到最后。且需要把把版本号的设置放到前面。
就是在使用commander的时候，需要先设置好版本号和帮助(-h)的操作。

comander最好是一个父选项里边有多个子选项，创建多个选项命令，选项命令下边的操作就是当前选项命令的操作，遇到下一个选项命令之前的操作。（当前commander的选项到下一个commander选项之间的操作）



####命令行工具####

用commander来实现命令行工具，实现的功能是ls的功能。
这个算是一个小的案例

如下代码的注释和逻辑：
```


const commander=require("commander");
const fs=require("fs");


commander.version("v1.0.0","-v,--version");
//子命令
/* 
    在这里有个非常奇怪的地方，就是创建了一个没有名字的子命令，而且还是必须带参数的，
    创建之后使用node ls无法在执行当前的action了。
    而是满足子命令的条件才会执行action里边的内容,命令为：node ls d: 这样才可以
    那是因为，一旦有子命令则父命令的action就会去满足子命令操作。父命令其实就不存在了。
    解决node ls也会执行命令，如下：
    原理：把父命令变成子命令的格式
    因为node ls d:  和 node ls的差别就是node ls d: 这个命令是带有参数，
    也就是process.argv会多一个值。所以我们只要在执行node ls时，给process.argv加上一个
    值，这个值刚好是当前目录的路径。
    表面上是node ls 实际上是 node ls __dirname  与子命令的格式一样。

*/

const subCommander=commander.command(" <path>");

//逻辑操作
commander.action((path)=>{
    fs.readdir(path,function(err,files){
        console.log(files);
    });

});

if(process.argv.length<3){
    process.argv.push(__dirname);
}

commander.parse(process.argv);

```


**ls显示目录的命令工具**：
第二种解决办法：
```
let commander=require("commander");
let fs=require("fs");
commander.version("v1.0.0","-v,--version");

//子命令的名称和文件名称一样，在执行命令的时候可以省略掉
/*
    不知为何action必须要写在commander(父命令)中才能生效，
    这个会不会和版本号以及commander.parse()有关系呢。我打算尝试以下。
    结果是：无法使用。

*/
// let subCommander=commander.command(" <path>");


commander.option("-p,--path [path]","print path",__dirname);
commander.action((path)=>{
    fs.readdir(commander.path,function(err,files){
        console.log(files);
    });
});

commander.parse(process.argv);
```


**注意:**

1,action中的参数会根据一定的条件发生改变。如果没有option设定选项，则action函数中的参数为process.argv中的值，也就是子command(" <pre>")匹配的值。如果存在option设定选项，则action函数中的参数为commander整个对象，如果要获取在命令行中输入的参数，则通过括号的方法（commander.选项名称）来进行获取。

2，**自我总结**：我把commander命令工具分成两种模式，一种是选项模式，一种是子命令模式。

3，如果设置一个不能接收参数的选项，如：commander.option("-l,--list","show file")  因为没有必填和选填[]和<>所以是不能接收参数。这个命令在commander的值只能是布尔值。如果命令加上了 -l 则commander.list为true。如果不加则为false。

4，action中函数的值接收的是command("createName <pre1> <pre2>"),则函数的形参一一对应即可接收。接收的是pre1和pre2的值。

**commander的执行顺序**

commander.parse(process.argv);这个操作执行后才会有后变的commander的其他的操作。


####chalk插件####

**这个插件的作用是：** 在命令行工具中改变命令行中字体颜色背景大小等。


首先：安装chalk
npm install chalk 

使用如下：
第一步：当然是引入这个插件
let chalk =require("chalk");
console.log(chalk.blue.bgGreen("nihao"));

则在命令行的工具栏中，如下显示：
![image_1cu0pi6ub14c3mq8lr612ng1cco9.png-5.9kB][7]


####与用户进行命令交互的inquirer####
使用方法如下：
下面的代码可以直接复制使用，依赖只有inquirer 

```
    let inquirer=require("inquirer");
/*
    在prompt的数组中只能放question对象，question的对象的格式如下：
    type 表示的是以哪种提问的方式来询问用户，

    type类型：
    input(填写框，默认值给字符串),
    list(单选，选项需要用choices数组,默认值是数组下标或值都可以),
    rawlist(单选，与list类似，不一样的是：选项需要手动写下标不能使用上下箭头选择)
    confirm(询问句yes或no回答,默认值给布尔值)
    checkbox(多选,与list类似，但是choices的值用name-value的json格式代替,value表示用户看到的，可以是中文等，value是answers收集到的值。
    默认值是：checked:true，是加载choices中被选中的json对象中的
    操作：空格代表选中，a代表全选，i代表反选.)

    验证：    
    validate(验证，这个不是type类型。它是一个函数，如果用户输入的满足要求则返回true，则直接下一步，
        如果用户输入的不满足要求，则返回提示用户错误信息，继续输入。
        一般使用在input类型里边)   
    
    过滤：
    filter(过滤，就是把用户输入的数据进行过滤，return 返回过滤的结果)


    下边的这些属性是根据上边type的属性的不同而发生改变的:
    name 这个是给程序员使用的
    message 这个是用户看到的
    default 这个是默认值


    answers是用户输入的答案
*/
inquirer.prompt([
    {
        type:"input",
        name:"username",
        message:"请问您的应用名称是什么呢？",
        default:"app",
        //val是用户输入的值
        validate(val){
            if(val.trim()==""){
                return "用户名不能为空，请重新输入"
            }
            return true;
        },
        filter(val){
            //用户输入的都会转成小写
            return val.toLowerCase();
        }

    },
    {
        type:"confirm",
        name:"userEs6",
        message:"是否支持es6",
        default:true

    },
    {
        type:"list",
        name:"framework",
        message:"支持的框架",
        choices:["vue","react","angular","jquery"],
        default:1
    },
    // {
    //     type:"rawlist",
    //     name:"rawframework",
    //     message:"请输入您支持的框架",
    //     choices:["vue","react","angular","jquery"],
    //     default:1
    // },
    {
        type:"checkbox",
        name:"checkboxframe",
        message:"请输入您支持的框架",
        // choices:["vue","react","angular","jquery"],
        choices:[
            {
                name:"使用bootstrap",
                value:"bootstrap",
                checked:true
            },
            {
                name:"使用github",
                value:"github"
            },
            {
                name:"使用Eslint测试单元",
                value:"eslint"
            }
        ],
        default:1
    }

]).then((answers)=>{
    console.log(answers);
});

```

####去掉node直接运行文件####

**基础知识**
hello.cmd
则在hello.cmd中可以写cmd命令，在当前文件下的命令行里边直接输入hello即可运行文件。如：hello.cmd中输入echo "nihao"
![image_1cu0vkr9m66brp01j7vd4i1ep116.png-8.3kB][8]

但是还是存在一个问题，就是会有echo "你好" 这样的提示。


**实际实现**
所以我们就接用能够直接运行的cmd文件，地址改成我们需要运行的文件，即可。

就是找到一个cmd的文件，改下地址就可以，例如下图就是：

![image_1cu1800kvdcb4jh1oa81i3g1vgp4j.png-31.9kB][9]

两个文件放在一起，把上边的地址改成下边的那样：

![image_1cu181lcf1bqp3s41snl1bfo1kr65g.png-34.2kB][10]


####commander多个参数传递问题####


action中函数的值接收的是command("createName <pre1> <pre2>"),则函数的形参一一对应即可接收。接收的是pre1和pre2的值。



####全局安装install问题####

我们一般用npm发布到网站上的文件，在安装的时候都是

在package.json中填写bin属性并且值为要执行的文件。
![image_1cu19m39u2co1r77fij1emm8s75t.png-19kB][11]

或者是如下：
```
    "bin":{
        "name":"index.js"
    }
```

但是我们如果要想在命令行执行后直接出现执行结果，还需要在文件的最上边写如下操作：
```
    #!/usr/bin/env node
    
```

那么在通过npm进行安装的时候，就会自动生成执行bin的执行文件，window上是cmd文件，mac上是shell文件。
我把这个包发布到了npm上边
![image_1cu1bv77m1pmktpts15rlj1q1h9r.png-6.3kB][12]
然后我在另外一个文件里边进行安装，
如下：安装了这个包
![image_1cu1br17cs0j14ee6apoirb0i91.png-4.9kB][13]
如下：安装之后如果您在package.json中有bin的属性，就会有如下.bin的目录


![image_1cu1bp29e8c7vql1vdup8p134d74.png-3.7kB][14]

点击bin的目录进去后会看到window的执行文件和mac的执行文件如下图：
![image_1cu1btah48lb1b55176t13l4re9e.png-5.6kB][15]

**如果我把它进行全局安装**
如果全局安装之后，就去如下文件夹进行查看：
![image_1cu1c3s49i4u192ehvc174s1mha8.png-10kB][16]


###GUI图形界面###
####Electron####
node版本和electron的版本的控制

**步骤**
```
    //第一步 还是npm init package.json指定入口文件为index.js，在目录里边创建index.js文件
    
    //第二步:npm install electron  安装electron
    
    //第三步：不能用node去执行这个index.js文件，而是用electron来执行。
    在node_modules中寻找electron的bin文件中的electron，同时有electron的cmd文件。用electron index.js 来运行这个index.js文件。
    
    注意：要执行的文件得是package.json中main 指向的文件。
    
    //第四步：简化执行
    ./node_modules/.bin/electron . 这个表示的是执行当前的文件，当前的文件指的是 package.json中的main所执行的文件。
    简化操作：npm run dev  则是在package中的script属性的值中，添加如下操作："dev":"./node_modules/.bin/electron ."
    
    //第五步：主进程和渲染，以及electron的事件、方法、属性。
    app对象是electron直属对象
    electron有自己的生命周期，这里主要说几个重要的生命周期
    ready就是当electron初始化以后，就会执行这个里边的操作
    如下代码：
    
    const {app}=require("electron");
    app.on("ready",function(){
        console.log("hellow ,I am Hu Minggui");
    });


    在控制台运行后输出的内容如下：
    
    C:\web\miaov\node\GUI\elec_app>npm run dev

    > elec_app@1.0.0 dev C:\web\miaov\node\GUI\elec_app
    > electron .
    hellow ,I am Hu Minggui
    
    
    //app对象退出方法大的操作：
    app.exit();
    
    
```

####electron窗口的实现####

BrowserWindow  是electron的类

new BrowseWindow(); //默认窗口,需要写在程序初始化后执行的事件里边。

如下代码：

```
    const {app,BrowserWindow}=require("electron");
    
    app.on("ready",function(){
        // console.log("hellow ,I am Hu Minggui");
        new BrowserWindow();
    });
    
    
```
new BrowserWindow(options);
options是一个json;而这个json里边可以写很多的选项。{width:,height,title}等

let bw=new BrowserWindow(options);

bw.webContents属性， 返回与网页相关的对象，与浏览器的window类似
这个属性下边有一个方法为：openDevToos();打开窗口的开发者工具，因为本身electron的窗口就是一个小型的浏览器。
所以为：bw.webContents.openDevToos();

bw.id 返回窗口唯一id

**重点内容：**
这个是加载页面到窗口中，可以是相对路径和绝对路径，但是推荐相对路径。并且，"./"是当前electron整个项目的根路径作为当前路径。
bw.loadfile("./layout/index.html");

注意：有的时候相对路径会有默认的地址，导致无法正常加载。这时就使用绝对路径。
bw.loadFile(path.join(__dirname,"layout/demo.html"));

bw.loadURL("https://www.miaov.com");//支持文件，也支持http协议的网址形式


#####--窗口#####

窗口分成一般窗口、无边窗口、透明窗口；

```

    new BrowserWindow({
        frame:false //无边窗口
        transparent:true  //透明窗口
    });

```

**父子窗口和模态窗口**

只要在子窗口设置parent:父窗口变量
并且子窗口永远是活跃在父窗口前面

```
    let bw=new BrowserWindow({
        // frame:false,
        // transparent:true
    });
    bw.loadFile("./layout/index.html");

    let bwChildren=new BrowserWindow({
        width:300,
        height:400,
        parent:bw， //设置父窗口为bw
        modal:true  //设置模态窗口
    });
    
    
    如果是模态窗口只需要在子窗口里边加上一个属性modal:true,则表示子窗口为一个模态窗口。与父子窗口不同的是，模态窗口必须操作子窗口后，才能激活父窗口。如果只是父子窗口，那么是可以直接操作父窗口的。
```


#####--菜单#####

需要两个类，一个菜单类（Menu），一个是菜单选项类(MenuItem) 

```
    const {app,BrowserWindow,Menu,MenuItem}=require("electron");
    
    app.on("ready",()=>{
        let bw1=new BrowserWindow(); //创建窗口
    
        let m1=new Menu();  //创建菜单，菜单分成顶部菜单和右键菜单
    
        let mi1=new MenuItem({ //菜单选项，type表示类型，label表示的菜单的文字
            type:"normal", //表示的是普通的菜单
            label:"文件"
        });
    
        m1.append(mi1); //把菜单选项添加到菜单里边
        
        //子菜单的创建，需要关键字submenu
        
        /*
        如果有子菜单，那么菜单选项就不是一个普通的类型normal而是一         个submenu类型
        同时，submenu类型作为属性，值是一个数组，数字里边就是子菜单         选项
        */
    let mi2=new MenuItem({
        type:"submenu",
        label:"查看",
        submenu:[
            {
                type:"normal",
                label:"文件"
            },
            {
                type:"separator" //分隔符
            },
            {
                type:"checkbox" ,//选项符号
                label:"选项一",//
                checked:true//默认情况下是选中的
            },
            {
                type:"radio", //单选
                label:"单选一",
                checked:true //表示默认情况下选中了
            },
            {
                type:"normal",
                label:"文件夹"
            },
            //非常重要的一个只是，role叫做角色，就是系统已经实现好的粘贴复制退出等等，我们只需要根据角色的值不同，而操作不同的效果即可，例如以退出为例。
            {
                role:"quit",
                lable:"退出"
            },
            /*
                自己手动实现退出的功能，
                菜单选项的点击功能的实现，就是在菜单选项中加一个属性函数，click(){} 在里边的操作就是点击实现的操作。
            */
            {
                type:"normal",
                lable:"退出",
                click(){
                    app.quit();
                }
            }
            
        ]
    });
    
        Menu.setApplicationMenu(m1); //通过这个静态方法把菜单添加到窗口的最顶端。
        
        
    });
```

**疑问**：大家或许好奇，为什么菜单可以不添加到窗口里边？
因为在这里只是把菜单选项添加到菜单里边，默认是所有的窗口都添加了这个菜单。


**重点知识点强调：** role是个角色的功能，那么这个角色的功能是用来实现系统默认的各种功能的，例如：复制，粘贴，剪切，关闭等等很多，可以根据electron文档进行查询且操作。


**MenuTtem的属性**，可以根据menuitem中的属性来辨别是否选中了当前的选项。这个同样参考文档。

**菜单实现点击功能**

```
          /*
                自己手动实现退出的功能，
                菜单选项的点击功能的实现，就是在菜单选项中加一个属性函数，click(){} 在里边的操作就是点击实现的操作。
            */
            {
                type:"normal",
                lable:"退出",
                click(){
                    app.quit();
                }
            }
            
```

####数据共享####

如果有两个窗口，那么窗口之间的数据该怎么共享。

主进程：就是index.js
渲染进程：是执行html结构的网页。网页里边如果要想使用在主进程中定义的数据，那么需要用electron中的remote类中的remote对象下的一个方法，这个方法是getGloabal("key值")来获取在主进程中，放在全局的数据。
也就是主进程把数据放在全局，渲染进程才能获取。
如下代码实现：

```
    //这个是在index.js的文件中写的代码
    const {app,BrowserWindow}=require("electron");

    let username="username";
    global.username="laohu";
    app.on("ready",()=>{
        let bw=new BrowserWindow();
        bw.loadFile("./layout/index.html");
        bw.webContents.openDevTools();
    });
    
    
    //下边这个是在渲染进程html中写的代码：
    
    <body>
        <h1>app</h1>
        <script>
            /*
                因为在渲染进程中无法使用BrowserWindow，因此我们这里需要用到remote这个类
            */
    
            const remote=require("electron");
    
            console.log(remote.getGlobal("username"));
        </script>
</body>



```

#####--进程之间数据的共享#####


在渲染进程使用的是：ipcRenderer这个类。
进程之间的通信是渲染进程中使用的ipcRenderer ，主进程使用的是ipcMain 
**切记：这里是渲染进程主动发送信息:**
ipcRenderer这个只能在渲染进程中使用
ipcRender是electron的对象
ipcRender.send("事件1"，data数据);
ipcRender.on("事件2",function(e,数据){
    e.sender.send(....) 同下边是一样的
});//监听数据


主进程是ipcMain.on("事件1",function(e,数据...){
  e.sender.send("事件2",数据); //那么这个数据是给ipcRender进行监听的。
});

代码如下：


```

//index.js代码
    const {app,BrowserWindow,ipcMain}=require("electron");
    
    let json={
        name:"huminggui",
        age:30
    }
    app.on("ready",()=>{
        let bw=new BrowserWindow();
        bw.loadFile("./layout/index.html");
        bw.webContents.openDevTools();
        ipcMain.on("getDate",function(e,key){
            e.sender.send("setDate",json[key]);
        });
    });

    
//渲染代码：
    <h1>app</h1>
    <button>点击</button>
    <script>
    
        const {ipcRenderer}=require("electron");
        const buttons=document.querySelectorAll("button");
        buttons[0].onclick=function(){
            ipcRenderer.send("getDate","name");
        }
        ipcRenderer.on("setDate",function(e,data){
            console.log(data);
        });
    
    </script>
    
    
```


**主进程主动发送信息** 

bw.webContents("事件名",数据);


#####--窗口之间数据的共享#####

1，之前学过两种数据的共享一种是gloabal 这种使用全局的方式，容易乱，用起来不方便。

2，ipcMain和ipcRenderer这种，如果是窗口之间进行数据的共享比较麻烦。

3，所以我们这里用到了第三种数据的共享，localStorage 本地储存。因为这种数据的存储是不需要用到主进程的，完全是窗口之间的数据的共享。

因为eclectron有浏览器的特性，所以可以使用本地储存。一个窗口储存多个窗口都能够获取。

localStorage.setItem(key,value);
localStorage.getItem(key);



```
//主进程index.js,因为这种数据的存储是不需要用到主进程的。

    let bw=new BrowserWindow();
    bw.loadFile("./layout/index.html");
    let bw2=new BrowserWindow();
    bw2.loadFile("./layout/index2.html");
    bw.webContents.openDevTools();
    bw2.webContents.openDevTools();


//bw加载窗口index.html中的内容
    <h1>app</h1>
    <button>点击</button>
    <button>存储</button>
    <script>
        const {ipcRenderer}=require("electron");
        const buttons=document.querySelectorAll("button");
        buttons[0].onclick=function(){
            ipcRenderer.send("getDate","name");
        }
        ipcRenderer.on("setDate",function(e,data){
            console.log(data);
        });
        //点击把字符串存入到本地存储中
        buttons[1].onclick=function(){
            localStorage.setItem("username","dongbinhong");
        }
    </script>



//bw2窗口加载的index2.html的内容
    <h1>app2</h1>
    <button>显示</button>
    <script>
        let buttons=document.querySelectorAll("button");
        //点击显示按钮，从本地存储获取存储的内容
        buttons[0].onclick=function(){
            console.log(localStorage.getItem("username"));
        }
    </script>

```

####案例：electron实例####
技术：vue 、node 、electron
#####--无边框如何拖动#####
-webkit-app-region:drag;在指定的模块中设置这个css样式。
如果不要拖动则在指定的模块中设置：-webkit-app-region:no-drag;
推拽可以参考如下：
[css的拖拽][17]



##vue##

###基础知识###
####forEach  for-in  for  for-of的区别####

复习基础的知识点：数组的常用的方法
forEach:这个是遍历，没有返回值的，并且不支持return，不管你写不写return都会执行完毕。
for循环是编程式，就是知道怎么实现的。
forEach 是声明式，不知道里边是怎么实现的。

使用for-in的时候，是keyfo数字的方式(for(let key in arr))。key值会编程成字符串，并且会把循环数组出数组的私有属性。支持return。

for-of，它支持return 并且是值offor(let value in arr)数组，不会把数组的私有属性遍历出来。不支持迭代,所以不支持对象的遍历。

Object.keys(obj) //把对象的key作为一个新的数组

####filter的使用####
特点：
不操作原数组
过滤后的新数组
函数，就是返回true放入新数组，否则不妨。




#####return的坑#####
```
return 2<item<5; 这个永远返回的是true。因为会先比较2<item 如果为真则为1，而1<5。如果为false，则为0，0也小于5.所以不管为真为假都小于5，所以返回的一定为真。

```

####map####

```
    把原有的数组映射成一个新的数组。

    特点：
    不操作原数组
    返回新数组
    返回的是当前函数返回的一项。（当前的循环的项由函数返回的项代替）
    
    
    
```

####includes####
```
    arr.includes(值) //是否包含这个值，返回布尔值
    
```
####find####

找到具体的某一个项用find

```
    //找到那一项，不改变原始数组，找到了后就不找了，会把找到的值返回。找不到返回的是undefined
    例如：
    arr.find(function(item,index){
        return item.toString().indexOf(5)>-1;//哪一项是包含有5的,就返回哪一项。
    });
    
    
    
```

####some 和 every####

```
/*
    some返回的永远是布尔值，只要是true，找到true后停止。找不到返回false。
*/

arr.some(function(item,index){
    return 条件。
});

/*
every返回的永远是布尔值，与some相反，只要是false，则停止，返回false。找不到返回true。 

*/
```


####reduce####

```
    /*
        4个参数，prev next index item 
        prev的是值上一次的值，如果是初始值则为数组第一项，如果已经循环了，那么则上一次循环的结果。
        next是当前循环，初始值是数组的第二项。那么下一次是循环就是数组的第三项了。
        index是索引，默认是数组的第而项，它的索引代表的是next的循环的索引。
        item代表的是正在操作的数组
    */
    求和如下实现
    let sum=arr.reduce(function(prev,next,index,item){
        return prev+next；//这个结果是next下一次的上一次
    });

    这个函数可以简化为：function(prev,next){}
    
    //默认指定prev，如果默认指定prev，可以理解为则next从数组的0项开始，其实是数组的第一项加了一个0，就会把形成如下[0,json1,json2,json3]的格式,next就直接执行json1了。默认给prev指定值的书写方式如下：
    
    arr.reduce(function(prev,next){
        ....
    },0);//这个0是prev
    
    
```

####箭头函数####

```
1,箭头函数是不具备this和arguments的

2,闭包：

函数执行的一瞬间叫做闭包。

全局作用域是浏览器关闭时会销毁。
如果一个函数没有引用，那么这个函数就会被销毁。
如果是函数那么函数执行后就会被

但是有一种情况是函数执行完毕后，还是不会被销毁的，如下：

let a =function(a){ //当a函数执行完毕后，同时返回了一个新的引用（函数），这个新的引用并没有执行，所以整个函数都不会被销毁，因为外边函数销毁了，里边函数也就没有了，所以直到返回的function也被执行了，则同时销毁两个函数。
    return function(b){
        return a+b;
    }
}


函数执行的一瞬间叫做闭包。


```

###vue基础###

框架和库的区别：
库：只提供解决部分问题，被动的。被别人调用。小
框架：一个用完完整的解决的方案，主动的得按照框架来。渐进式框架(全家桶是完整的框架：vue+vue-router+vuex+axios)。(大)
构建工具：vue-cli  
vue是数据驱动
vue是mvvm 模式：m  modal 数据 、c controller 控制、v viewModal 视图模型 ；

mvvm和mvc的区别：
m 是js数据结构，vm是view-model，v是视图。
以前的mvc是用户输入数据到数据库查询后返回给页面，但是页面数据更改无法改变后台的数据。
而mvvm是，用户输入数据后，把数据绑定到了vm的视图模型，分配给页面，同时监听视图模型，一旦视图模型数据改变，那么会改变后台或者页面的数据。例如：用户改变数据，则视图模型监听到后，会改变后台数据。同时后台改变数据，则监听vm的也会反馈给用户页面进行更改。实现双向数据绑定。



```
    //cdn的方式，就是网址
    /*
        vue的使用分两种，一种是引入和jq一样，这种一般用于小型的项目中。一种是安装，用作大型的项目。
    */
    
    
    /*
    兼容性  ie8以下的浏览器是不能使用vue的
    因为vue中使用了Object.difineProperty(es5);而这个没有替代方案。
    所以ie8以下就不支持了。其他能够兼容es5的浏览器都能够兼容vue。
    */
    
    /*
        安装方式： npm init 先进行项目依赖的创建。
        package.josn中项目的名字规则为:不能是 大写、中文、特殊字符。
        并且package.josn中是不能够写注释的，这个规则是根据json来的，json中不能够写注释。
       并且项目的名字不能和要安装的依赖的名字一样。
       
       npm install vue 进行安装
       
    
        
        
    */
    
    
    vue的创建以及mvvm的简单说明:
    
    let vm=new Vue({ //vue的构造函数，创建了一个视图模型，也就是viewModal，就是绑定数据的那个。
        el:"#app", //vm操作的dom结构范围，不能是html和body（表示的是视图）
        data:{// 数据，这个数据是由vm代理的 (modal数据)
            "msg":"hellow"  //这个数据是vm.msg可以直接获取，因为是vm代理的数据。
        }
    });
    


    {{}} 表达式：
    这个是视图view的表达，可以把vm下边的属性直接写入{{}}里以直接显示出来在页面。例如:<div>{{msg}}</div>
    {{}}可以写：赋值，取值，三元运算
    
    

```

####vue的指令####

```
   
    如何实现双项数据绑定：
    /*
    实现双向表单首先页面得是表单元素。在dom结构上添加行间属性，并且行间属性以 v- 开头的。
    */
    如果是表单元素，并且表单元素上加上v-model后，表单的元素的value、checked、selectd 这些属性都没忽略掉了。
    @ v-model:
    是双向数据绑定。v-model的等于的是一个变量。这个变量就是表单元素的值。例如：
    <input v-model="msg" /> 
    如果改变表单元素的值也会影响msg的值。
    
    
    
    
    
    
    defineProperty的使用：
    /*
        这个是es5的方法,
    */
    //用来定义一个对象中的属性，这里是说的是name属性，只是我们对这个属性有跟多的设置而已。

    Object.defineProperty(obj,"name",{
        value:"值",//用来定义这个属性的值
        //当然还有其他的属性进行限制，但是这里最重要的是两个方法：
        get(){ //这个方法是当obj取值时调用
        },
        set(val){//这个方法是obj修改值时调用
        }
    });
    详细代码和解释如下和图：
    
    <input type="text" id="input1">
    <script>
        /*
            我们用Object.defineProperty设置一个对象为obj的属性，假如这个属性为name。
            给obj赋值时会调用defineProperty中的set方法，如果直接给obj赋值，又会再一次调用
            defineProperty中的set方法，这样就是一个死循环了。
            所以，我们定义一个空的对象temp，temp有一个同样的name属性。当给obj赋值时调用obj的
            set方法，在set方法里用temp.name=val;也就是用temp对象的name属性来接收这个值。
            当obj取值时，取值时调用的是get方法，再把这个temp.name返回出去。

            如何模拟vue的v-model指令呢？
            监听表单的input事件，input输入框发生改变时，
            把这个输入框的value值赋值给obj的name属性。
            当obj.name赋值时，我们就把这个赋的值给input的value。
        
            
        */
        let input1=document.querySelector("#input1");
        let obj={};
        let temp={};
        Object.defineProperty(obj,"name",{//给obj添加属性
            get(){
                return temp.name;
            },
            set(val){
                temp.name=val;
                input1.value=val;/*只要给obj赋值就能改变input的值*/
            }
        });
        input1.value=obj.name;//页面一加载就输入框就会有值
        input1.addEventListener("input",function(){
            obj.name=input1.value; /*input发生改变时把值赋值给obj，而obj赋值时调用set方法而
            改变temp的值*/
        },false);

    </script>
    
```

![image_1cuj8bbib1snrlvaiuinmpsk89.png-27.4kB][18]


v-text="变量" 与 {{}} 是一样的
{{}}弊端就是页面还没有加载数据时，{{}}会显示出来。

v-cloak的使用，解决闪烁的问题：
sytle中：[v-cloak]{display:none;}在dom结构中v-cloak 加上这个。在这个包含的块里边就不会闪烁。【理解就好】

v-once
只绑定一次，当数据再次发生变化时，也不会导致页面刷新。
这个的使用方法与其他的使用方法是不一样的,还是要用到{{}}。如下
```
<div v-once>{{name}}</div>
```

v-html :
把字符串当作html渲染


#####--vm中的数据#####

如果是data里边的数据是一定要初始化的，否则不会是响应式数据。
可以在data外边添加响应式数据：
vm.$set(obj,property,value); //obj是给data中的哪个对象加，property是加的什么属性，value是属性值是多少。
另外一种方式是：vm.obj={key,value};这样也是可以的，只不过这样就是对整个obj一起操作了。这里的boj还是上边的obj。

**原理和不能双向数据绑定的数据:**
双向数据的实现原理是get和set方法，就是具备这种方法的属性才能够实现的。
**不能导致页面数据变化的方式如下**：
不能实现双向绑定的原理的数据是：数组arr值的 和以及数组长度
vm.arr[0]=100;//如果这样去改变data数据中的数组的值，则不会改变data数组中的值的。因为数组中的值是不具备get和set方法的。
vm.arr.length-=2;//这也是无法改变的。
这些是不能够通过vm.arr的方式进行更改的。

**数组能通过vm改变数据的是**：
vm.arr=[];//赋值一个新的数组。
av.arr.fn();//数组的方法，如 filter map 等这些方法都是能够实现的。

#####-（v-for）指令#####

```
    要循环谁就在谁的身上加上v-for。
    
    如果v-for只有一个参数则是value，如果有两个参数则需要加上括号表示。v-for="(value,key) of arr"。
    在vue中of和in是相等的，但是我们尽量用in来表示，少用of。
    
    复杂的数据一般是对象套对象，不会是出现一个三维数组，因为数组的循环会降低效率。
    
    v-for 可以循环字符串。如：v-for="key in 'aaaaa' " ,则每次循环都是输出单个的a
    
    v-for对json对象循环可以是3个参数。如下：（value,key,index）in json
    
    
```


#####--事件指令#####

```
    如果我们把事件写在行间，为什么点击事件的方法需要加上括号呢？如：
    <div onclick="fn（）">点我呀</div>
    <script>
        function fn(){
            alert(1);
        }
    </script>
    
    以上代码中可以不可以把行间的onclick="fn"呢?
    回答是：不可以的，如果改成这样点击时就会报错。如果在行间添加事件，则方法必须加上括号。因为行间添加的事件是把要执行的方法放入行间事件里边。如下代码：
    ƒ onclick(event) {
        fn()
    }
    点击时，是执行onclick这个方法里边的内容。如果fn不加括号那就变成了fn了，这样肯定会报错的。
    
    
    v-on:click="fn"  但是一般把v-on简写成
    fn放入到methods里边。methods:{fn:function(){}},并且methods里边的方法都是执行实例。方法里边的this 是zhi
    不管是方法还是数据，定义之后都是放入到vm上边，所以不能同名。
    
    v-on的传值以及是否需要写括号的问题：
     methods:{
        fn:function(event){
            console.log(event);
        }
    }
    上边的方法函数中有一个参数为event，这个event是事件源。也就是哪个dom操作的这个事件。
    如果@click="fn"，表示不需要传递参数，则event默认就是点击的事件y源头。如果@click="fn()"也就是方法加上括号，那么表示需要传递参数，event需要参数传递过来才能使用。如：@click="fn($event,1)" $event表示事件源头，1实参。那么methods中接收的方法应该如此：function(event,a);参数需要一一对应。如果@click="fn()",不写参数，又加了括号，那么methods中的方法fn(event),这时的event是undefined 
        
        
```

#####--vue中键盘修饰符#####
我们的键盘操作，虽然在vue中可以使用 "keyCode==数字" 这样的方式来表示键盘按到了哪个键。但是vue中有新的修饰符表示的。如下：
```
    @keyup.enter 或者是 @keyup.13 表示的是回车
    @keyup.a  或则是 @keyup.A 表示的是按了键盘的a键后的操作。
    @keyup.ctrl.a 表示的是按住键盘中的ctrl+a 后执行的事件

```


#####--checkbox和select中使用v-model#####

```
    checkbox:  中加上v-model="值" ，这个表示的是否被选中，如果值为0表示没有选中。如果只有一个复选框的时候，会把此值转换成布尔类型。可以没有value值。
    
    如果是多个checkbox，这个比较恶心的语法：
    那么v-model="值"，这个值必须是数组，并且checkbox类型的表单必须有vlue值，并且这个value值的值都是不同的。如果我们选中了一个checkbox，则会自动给v-model中的数组添加value的值。如果没有选中则不添加。
    
    这里注意的是：只有一个checkbox则v-model放布尔值，如果是多个checkbox则v-model放数组。
    
    
```

#####--vue中的钩子函数####
钩子函数也叫做生命周期函数。
created(){} //数据被加载完成之后，执行操作。这里的数据指的是data里边的数据加载后执行。一般是用初始化数据使用的
特点：
1,this的指向也是vm
2,专门用来发送ajax的方法

ajax的库 axios 
当我们引入axios之后，那么我们就可以直接使用：
```
axios.get("./...json"）.then(res=>{},err=>(){});
//在这里需要用箭头函数，因为这里需要用到this，这个this必须是vm，如果不用箭头函数，那this就是指向window。

```
#####--（v-bind）和：号#####
如果是html结构的中的属性的值需要用vm中的变量来表示的话，属性需要加上加上v-bind或者是：号。

```
    <img :src="address_image" /> //动态绑定数据
    
    v-model.number="" 表示input中val的值变成number类型。
    
    v-model.lazy="" 当输入框失去焦点时更新数据 或者是：v-model.number.lazy 这样也是可以的。
    
    
```

####vue的过滤器####

原数据不改变，只是显示的方式不一样。

```
    | 管道符
    {{100 | tofix（参数）}} //管道符后边的tofix是一个方法，是过滤的方法，那么这过滤的方法的实现在什么位置呢，在vm的挂载上。
    
    filter:{
        tofix(input，prame1){  //注意：这里的this是window ，input参数是管道符左边的数据，需要被过滤的数据。prame1这个参数或者后边的其他的参数，都是管道符右边方法穿进来的参数。
        //所以，过滤方法在vm挂载的形数，要多于在dom结构中实参的参数多一个。
        
        
        }
    }

```

####购物车的实现####

input为checkbox时，获取的事件最好用change事件。

#####--全选的逻辑#####
    当全选按钮为true，则列表按钮则为true。当全选按钮为false，则列表按钮为false。
    当列表按钮有一个是false，则全选按钮为false。否则为true。
    
注意：当列表中的数据为数组时则可以用every，只要有一个为false，则就返回为false。


在vue获取数据之后做的操作，需要留意， 因为只有这样才能直到获取数据之后做什么操作。

可以直接把方法写入到html中的函数里边。{{sum()}} 但是不建议这么使用。因为不存在缓存。只要页面发生改变，它就会执行，那么有些页面的操作与计算无关，它也执行，则导致性能不好。


#####--购物车计算的逻辑#####
如果被选中则计算，如果不被选中则不计算。
全选中计算，不全选则不计算。
购物车的计算逻辑还是需要再加强的。


####计算属性computed####
computed也是放在vm上的。
同时也不能和method和data中的名字一样。
计算属性中只要有数发生变化，那就会进行计算。如果和计算属性无关的计算值则不会重新计算。
计算属性有get（）方法获取值时调用。set()方法，赋值时调用。
计算属性是有缓存的，如果依赖的值没有变化是不会重复执行的。
实例代码入戏：

```
     computed:{
                isAllcheckbox:{
                    get(){
                        return this.products.every(item=>item.isSelected);
                    },
                    set(val){/*当给isAllcheckbox赋值时调用这个方法,也就是在点击全选的时候执行这个。
                        val是绑定的表单的值，因为v-model进行绑定变量为isAllcheckbox,
                        所以表达发生变化时值传过来*/
                        this.products.forEach((item)=>{
                            item.isSelected=val;
                        });
                    }
                }
            }
            
            

```

####vue动画####
v-if  and  v-show 
v-if操作的dom。
v-show操作的是样式。
如果频繁的使用dom则用v-show。
当数据一开始就能确定下来的，则使用v-if则dom都没有更不会执行。如v-show会执行dom，只是dom不显示而已。

只有dom从显示到隐藏或者是从隐藏到显示才会使用dom的动画。


```
    .v-enter:{opacity:0;} //表示动画没开始时的状态
    .v-enter-active{transition:1s linear;}//表示动画进入后的状态,这里不用写opacity，如果写了会快速变成opacity这个状态，只写动画样式就可以。
    .v-leave-active{opacity:0;transition:1s linear;}//离开后的动画状态。
    
    针对哪个标签进行的操作,如下：
    <transition>
        <div></div>
    </transition>
也就是上边的样式是针对下边的这个dom结构进行的操作。
我么可以给transition加上一个name 属性，则name属性为mg。那么在样式上可以用mg替代了v。如：mg-enter:{...}





```


#####--动画库animate.css库#####
 npm install animate.css

link的方式引入animate.css,则引入的方式是 node_modules/animate.css/animate.css

animate.css中属性的样式必须带上 animated 
注意：enter-active-class  进入时的动画
leave-active-class 离开时的动画
```
    <transition enter-active-class="animated 样式类" leave-active-class="animated 样式类">
        <div></div>
    </transition>
    
    第二个重点：
    在<transition>中不能够使用v-for，如果使用v-for就必须要在v-for的外层加上<ul>标签。
    所以当我们需要进行v-for的相关操作时，我们需要用<transtion-group>标签。
<transition-group>
    <div v-for="(item,index) in arr" :key="index"> </div>
</transition-group>

在这里是必须要在v-for上加上:key="index"的，其实这个是给div做索引，否则并不知道循环到了第几个div,第几个div进行动画效果。
key的属性主要是当运动的时候，用来区分哪个隐藏哪个显示的作用。

v-for会默认恢复原有的dom结构，所以在用transition-group和animate进行动画时，会发现只有第一个出现动画效果，而之后的不出现动画效果。那是因为v-for恢复了之前的dom结构，只是把值给传入到dom结构里边，而key属性并没有变化。所以把key属性的值设置为Math.random();如, :key="Math.random()" 这样即使恢复了dom结构但是key值会发生变化，那么动画也会认为是在不同的dom结构，而进行动画效果。

```

####vue事件源和事件绑定####

```
阻止冒泡：在@click.stop="..."   //这里的.stop就是组织冒泡的，vue中是用这样的方式来组织冒泡的。
.stop  阻止s事件传播，能阻止冒泡。不管是冒泡还是从上往下的事件都会阻止。  @click.capture.stop  这样写也是可以的

.capture 阻止捕获
.prevent  阻止默认事件

.onece  表示事件只触发一次,如果是冒泡也是只触发一次

.self 事件源 ，这个主要是只执行事件源是自己时才操作

```

######--判断input框是否属于规则#####
```
计算属性：
在计算属性中的set方法，如果set方法中执行的是把值给别的属性赋值，而并不是给自己赋值，那么自己就会没有值。
例如：
computed:{
    a:{
        get(){
        },
        set(val){
            this.msg=val; /*a并没有赋值到，值给了别人了，a就没值了*/
        }
    }
}



    通过input的框实现错误信息的提示：
逻辑：错误信息是算出来的，通过一个data属性绑定input框，通过输入的值不同，给计算属性的错误信息不同。


```

####watch的使用####
```
    computed 不支持异步操作。
    watch是监听数据的变化，支持异步。
    computed和watch的作用其实都是一样的，都可以计算实现值的变化。但是computed不支持异步，而watch是支持异步的。把属性的计算逻辑放入到异步操作中，watch是支持的。
    正常情况下：如果是异步用watch。除此之外，都用computed。
    
    解决这个办法。
    watch是观察者，就是当属性变化时会触发这个属性的函数。函数有两个参数，第一个参数是新值，第二个参数就旧值。如果新值和旧值一样，那么不会触发watch。
    a是data中的属性，而watch是监听这个属性的变化，并且是如何进行变化的。
    watch是挂在到vm上的。
    
    
    watch:{
        a(newVal,oldVal){
        
        }
    }
    
    watch可以设置中间状态，就是异步操作之前和异步操作之间，执行的操作。
    
    vm.$ 一般指的是vm的内部的方法，vm.$watch,自带的监控。
    
    
    
    
    
    watch的弊端:
    就是只有监听的属性变化才会发生变化，即使监听属性的依赖发生变化，watch也是不会变化的。
    而computed是依赖发生改变，则就会发生操作。
    {{方法实现}} 这个就是只要页面有变化，就会更新页面，而这种就是变化太多，浪费性能。
    
    
    
    
    
    watch默认情况下只监控一层数据：
    watch:{
        arr(){}
    }
    例如：数组  arr=[{a:1},{b:2}] ,如果arr.push({c:3});那么会监控的到。但是，arr[0].a=5;则监控不到，因为操作json里边的数据是不是第一层了。
    **深层监控： 
    监控数据不收受限制，只要更改了就会监控的到。
    则需要把arr(){}改成一个对象的形式arr:{handler(){},deep:true},这个里边的handler函数也是固定的,deep为true也是必须写的。
    
    
    
```

####v-if and v-else ####

```
v-else 和 v-if  一定要配合使用，v-else是不能单独使用的。且配合使用的作用是：如果v-if为false时，执行v-else中的内容。

```
####template标签####
template标签没有实际意义，是用来包裹元素用的

```
    v-show 不支持template,所以只有v-if使用
    
    在默认情况下，相同的dom会被复用，如果要让它变成不同的dom则需要加key属性。如：key="1",key="2" 来区别的不是同一个。
    
    谨记：vue中dom结构相同时会被复用。
    
    

```

####动态绑定样式:class and  ：style####

最常用的就是两种，一种是对象，一种是数组。

```
class 属性 和 :class是可以共有的

对象的表示方法，json中一般是通过条件判断
<p :class="{z:true,y:flag}">  //z和y是类样式写在style里边的类。flag可以是data的属性。

数组表示法，
    :class="[class1,class2]" //class1和class2都是变量，都是data中的属性。
    
还有一种方法是数组套对象：
    :class="[class1,{class2:true}]";
那么class和:class如果样式一样谁会被覆盖呢，class会被覆盖，因为:class是最后才执行，因为它需要后边的计算等操作才会开始执行。
    
    
 :style的使用：
    对象的使用法：
    :style="{backgroundColor:'red'}"
    
    数组的使用法:
    :style="[style1,style2]";//style1在data中是，style1:{font-size:'18px'},style2也是如此。
    
    

```

####vue路由###
```

浏览器自带的历史管理叫做：
1，history（history.push）
history.go(-1)就是浏览器后退一步。

1.1：
通过js使用history.pushState("","","/d");/*第一个和第二个参数都没有什么实际意义，第三个参数的/d中的d会以#d的方式添加到网址的后边，但是网页确是不跳转和刷新的，网页没变。但是会生成历史管理。
*/


2，还有一种是通过记录hash来记录网页的

总结：开发时使用hash，上线使用history。
```


####（中型项目）todoList案例####

```
    keydown  和 keyup 的区别：
    keydown比keyup少一个值，因为按keydown时值还没有传入。
    
    
    双击事件：
    @dblclick
    
    
    
    
    修改提醒事情的逻辑：
    目标是点击li 时，li中的模块一个显示，另外一个隐藏。技术难点就是，首先li有很多个，得先确认我点的是哪个li，然后再到点击的li里边去作判断。
    实现：
    1，双击li添加一个双击事件，这个事件的方法传递一个参数，这个参数为当前循环到的对象。在data公共属性设置一个cur为空。把双击事件方法中作为参数传递过来的对象赋值给cur。也就是说，公共属性cur的值为当前双击到的对象，所以每次双击li，那么cur的值都是当前双击li。（注意，这里是li循环，所以每个li都有一个对象，这个对象是存放数据的）
    2，然后在判断li里边的模块，如果是双击应该显示的模块，那么条件为cur==当前对象。（这个条件是其他的li都不满足，因为都不是当前的li）。如果不是双击该显示的模块，那么条件为：cur!=当前对象，应该隐藏。
    
    **逻辑总结：在一个列表中，每一个列表选项都有两个互斥的判断条件，如果当前列表选中的第一个条件成立了，那么当前列表选项的第二个条件则不会成立。而其他列表选项刚好相反，因为其他列表选项的第一个条件不成立，所以其它列表选项的第二个条件成立。所以才实现了列表中只显示其中一个列表选项的激活状态，其他选项的状态都是禁止的。   
    
    **智慧结晶：没有条件创造条件进行判断，在这里就是双击某一项，然后利用公共值，把这一个项作为判断条件。
    
    
    在vue中容易忘记一点是：v-model一旦绑定，那么只要输入框有值输入，那值就赋值了
    
    
    指令：是用来操作dom 的。间接的操作dom元素。
    
    
    钩子函数：
    页面的hash发生变化时，钩子函数不会执行，监听页面的hash变化的事件会执行。

    
    
    
    监控hash值:
    页面hash的变化，需要监听hashchange事件，就是hash发生改变时，就会执行这个事件里边的内容。获取hash值是window.location.hash
    
    本地储存：localstorage
    
```

####自定义指令####

```
    自定义指令是间接操作dom结构的。
    我们在vm下挂在一个 directives:{
        color(el,binding){ //省略了v-  ，使用时是v-color,
        /*
        el是当前的dom节点，bingding.value是在使用v-color的属性值。当然bingding是一个对象，可以看到很多的对象的属性。
        */
        }
    }

```

####钩子函数####
生命周期方法：
beforeCreate

created

beforeMount

Mounted

beforeUpdate

updated

beforeDestory

destoryed


```

    vue生命周期的实现过程：
    
new Vue()
---------->调用init(){这个方法是把vm下方法创建好,都是内部的方法}----->beforCreate(){就是把new Vue中的数据和方法创建好，如data和method中的。}
---------->created(){这个时候就可以操作vue实例中的数据了，主要是ajax操作或者是初始化操作}
---------->判断是否有el或则是vm.$mount(el){这里主要是找渲染的内容,如果有则继续往下走，如果没有则程序停止。}
---------->判断是否有模板template(如果有则走render的模板渲染，如果没有走el指向的dom结构)，{所以templeate的优先级大于el。template模板特点是：只能有一个根元素，并且不能只是文本元素。}
---------->beforeMount(){几乎用不到,这个是template替换el之前的方法}
---------->mounted(){这个是template替换el之后的方法，这时可以操作dom了，因为模板已经生成。}
---------->beforeUpdate（）{这个是数据更新之前操作，使用的特别少}，
---------->updated() {这个是数据更新完毕后的操作，很少使用，因为有watch监听数据的变化，所以这两个方法比较多余}
---------->beforeDestory(){就是当vm.$destory()方法执行之前。}
---------->destoryed() {销毁，销毁的是子组件，监听器。数据和方法是存在的。但是一旦监听器移除了，则数据绑定的操作则无法实现了。}


```

#####--mounted方法#####
```
vm中的属性哪些
vm.$data
vm.$el
vm.$watch
vm.set 就是给后边添加的属性实现响应式
vm.options  就是在vue上的所有的方法和属性，包括胡乱设置的。如：
new  Vue（{
    a:1,
    el:"#app"
}）；
上边的a也会出现在vm.options里边。


vm.$nextTick(()=>{//等待dom渲染完成后，获取vm


<div rel="my">
</div>
vm.$rels是指所有的ref属性的。获取是：vm.$refs.my ，这个获取的是dom结构，就是ref="my" 包括自己在内的所有的dom 结构。
弊端：就是只能获取一个。但是如果通过v-for循环出来的可以获取多个。

dom的渲染是异步的，所以在渲染的时候如果有数据的更改，并且有其他的操作，这个其他的操作会用到dom，那么这个操作最好是放入this.$nextTick()里边。因为那时dom并不一定已经修改过数据，所以等dom都渲染完了，肯定修改了，再进行操作是最准确的。





```

####vue的组件化####

```
一个组件其实就是一个dom结构。
例如:组件my-header那么为<my-header></my-header>

全局组件的设定：
Vue.component("my-header",{//一个对象，就是对这个组件的所有的设置
    template:"<div>我很好</div>"
});
那么我们在使用这个<my-header></my-header>时显示的内容就是这个template所对应的内容。
注意：
1，标签只认小写的（组建名不能带有大写，多个小写词之间用-线连接）；
2，html中用-线连接，js中用驼峰表示也可以的。
3,组件中的数据都是函数类型，data(){ return {} },这个返回的对象才是真正的数据，和vm中的data一样。自己的模板中可以取自己的数据。



    局部组件：
三部曲：
1，创建组件
    let homesome={template:"<div>hahahhahah</div>",data(){return{}}}；
2，注册组件
    components:{
        homesome:homesome
    }
这个组件是写在vm下边的

3，使用
    <homesome></homesome>

注意：
1，子组件是无法使用父亲vm中的data数据的（会报错）。如果使用就失去了组件的独立性了。
2，这些组件中是有生命周期函数的，以及data等都有
3，组件尽量不要使用相同的数据，需要保持独立性。也就是我们在两个组件外边定义一个数据，那么都是可以拿着使用的。
4,组件之间是可以无限嵌套的


    发布订阅：
听的不是特别的明白


    父子组件传值：
单项数据流，父亲能改变儿子，但是儿子不能直接改变，如果直接改变会报错的。只能是儿子向父亲发出申请，父亲更改了，儿子才能跟着更改。

实现代码如下：
<body>
    <div id="app">
        父亲:400,
        <!-- 父亲把值传递给子组件的方式如下 -->
        <childone :m="moneny"></childone> 
    </div>
    <script src="node_modules/vue/dist/vue.js"></script>
    <script>
        let vm=new Vue({
            el:"#app",
            data:{
                moneny:400
            },
            components:{//这个是父亲组件中的子组件
                childone:{//这个是子组件的名字，如果不是字组件名字是直接的key-value键值对.
                    props:{ //属性名和data中的属性名不一样，但是校验时不会报错，只会警告
                            //规定类型，默认是string
                        m:{//这个是父亲传递给子组件，子组件获取值的名字
                            type:[String,Function,Object,Array,Number,Boolean],
                            // default:0,
                            required:true,//这个属性不能和default同用,是表示这个属性必须传递
                            validator(val){//自定义校验器，val表示当前的值，返回true表示通过，返回false表示不通过
                                return val>300;
                            }
                        }
                    },
                    template:"<div>儿子:{{m}}</div>"
                    /*这里的m表示的是父亲传给它的值*/
                }
            }

        });
    </script>
</body>

以上是父子组件传递值的一种方式，如果我们在子组件中写如下代码：
template:"<div>{{m=1000}}</div>"
则这样是不可以的，这样是直接在子组件中修改子组建的值，是不能够这么实现的。




```

#####--父子组件#####

```
 

    父子组件：
    子组件是可以使用父组件的数据的，但是子组件并没有对父组件中数据的修改权限。如果子组件对父组件中的数据有要求那么需要通过this.$emit(方法,数据);进行请求。

    代码如下：
    <body>
    <div id="app">
        父亲:{{moneny}},
        <!-- 父亲把值传递给子组件的方式如下 -->
        <childone :m="moneny" @fatherchangedata="fatherUseData"></childone> 
    </div>
    <script src="node_modules/vue/dist/vue.js"></script>
    <script>
        let vm=new Vue({
            el:"#app",
            data:{
                moneny:400
            },
            methods:{
                fatherUseData(val){
                   this.moneny=val;
                }
            },
            components:{
                childone:{//这个是子组件的名字，如果不是字组件名字是直接的key-value键值对
                    props:{ //属性名和data中的属性名不一样，但是校验时不会报错，只会警告
                            //规定类型，默认是string
                        m:{//这个是父亲传递给子组件，子组件获取值的名字
                            type:[String,Function,Object,Array,Number,Boolean],
                            // default:0,
                            required:true,//这个属性不能和default同用,是表示这个属性必须传递
                            validator(val){//自定义校验器，val表示当前的值，返回true表示通过，返回false表示不通过
                                return val>300;
                            }
                        }
                    },
                    template:"<div>儿子:{{m}}<button @click='changeData'>更改数据</button></div>",
                    /*这里的m表示的是父亲传给它的值*/
                    methods:{
                        changeData(){
                            this.$emit('fatherchangedata',800);
                        }
                    }
                }
            }

        });
    </script>
</body>

简单的的逻辑实现：

父组件和子组件传值的实现是子组件自定义一个触发事件，这个触发事件绑定父组件的方法，从而改变父组件的操作。那么只需要在子组件中的dom元素中绑定一个事件，这个事件执行的方法中触发子组件自己的自定义事件即可。
触发操作为：this.$emit('自定义事件名'，传递参数); this是指当前的组件，一般是子组件。$emit是每个组件都有的操作。自定义事件名是绑定在自组件上的自定义事件，参数是自定义事件绑定的方法接收的参数。


**子组件和父组件生命周期中都有mounted方法，这个方法谁先开始执行呢？？？
是子组件先执行，因为父组件里边有子组件，如果子组件没有完成，那么父组件也是没有完成的。
但是如果我们去获取dom元素，则不一定会获取到准确的，因为mounted方法是异步的。所以一般在生命周期内获取dom元素数据时都会加上一个this.$nextTick(()={});这个表示的是dom结构数据加载后操作。



注意：
组件也是可以进行v-for操作的，但是组件进行循环的时候是需要带上key属性的。



发布订阅：
let EventBus=new vue;
这个是用于发布订阅的一个方法。它的作用只是用来发布订阅，并没有其他的功能。是各个组件之间没有存在关联，所以需要用它来连接形成关联。


```

#####--弹框（父子组件的实现）#####

```
代码如下：

<body>
    <div id="app">
        <button @click="flag=true">弹</button>
        <model :show="flag" @concel="shutdown"></model>
    </div>
  
    <template id="dilog">
        <div class="mark" v-show="show">
            <div class="alert">
                <button @click="closepopup">关闭</button>
            </div>
        </div>
    </template>

    <script src="node_modules/vue/dist/vue.js">
    </script>
    <script>
        let model={
            template:"#dilog",
            props:['show'],
            methods:{
                closepopup(){
                    this.$emit("concel");
                }
            }

        }

        /*这个是父组件*/
        let vm=new Vue({
            el:"#app",
            data:{
                flag:false
            },
            methods:{
                shutdown(){
                    this.flag=false;
                }
            },
            components:{
                model
            }
        });
    </script>
</body>








```


#####--插槽组件slot#####
```
    插槽组件slot：
第一点：我们在创建一个组件<model></model>如组件里边写了内容或者是标签，那么如何把这个标签写入到组件里的模板里呢。这时就需要slot标签了，就是在(template)模板的标签结构里边写入<slot></slot>标签，那么model里边的标签就会覆盖掉被放入到这个slot标签里边。在使用多个model标签时，标签里边的内容不一样，那么显示效果也不一样。

第二点：如果子组件model中有多个标签，并且多个标签的需要对应模板template中的slot标签，那么就需要指定。组件内的标签的slot属性对应slot标签中的name属性。为何叫做卡槽slot，就是因为一个卡对应一个槽的意思。

第三点：如果子组件mole里边没有放入对应的标签，那么在模板template中的slot标签之间的内容就是默认的内容，没对应标签时显示默认内容。如：<slot>默认内容</slot>

第四点：model中的标签没有指定的slot属性，会放入template没有name属性的slot标签中，并且有多少model内的标签都会放入slot标签中，如果slot有多个没有name属性，则多个都会放入。

第五点：在model中的标签里边使用变量，则哪些变量的作用域是父级的作用域。如下代码：
<model>
    <button @click="fn">点击</button> //则这个fn是属于父亲作用域的
</model>  //子组件
其实标签里边变量的作用域主要还是看标签是在哪个模板的作用域里边。以上模板是父亲的模板里边，只是父亲模板里边放了一个子组件，但是模板还是父亲模板，所以属于父亲作用域。



注意的内容：
1，template只有一个根元素
2，template浏览器是不显示的，显示的是一个document的碎片文档
3，卡槽对应，是把对应的标签放入slot中，但是在浏览器中slot中是不会显示内容的。
4，


----代码如下：
<body>
    <div id="app">
        <model>
            <h1 slot="filename">我是王八</h1>
            <p slot="desc">
                描述：王八是一种生活在还里边的生物，它的产生来自于很多的水和鱼，那个生长环境真的很好
            </p>
        </model>
    </div>
    <!-- template只有一个根元素 -->
    <template id="dilog">
        <div>
            <slot name="desc">我是默认值desc</slot>
            <slot name="filename">我是默认值filename</slot>
        </div>
    </template>
    <script src="node_modules/vue/dist/vue.js"></script>
    <script>
        /*子组件*/
        let model={
            template:"#dilog"
        }
        /*这个是父组件*/
        let vm=new Vue({
            el:"#app",
            components:{
                model
            }
        });
    </script>
</body>



父组件如何调用子组件的方法：
非常重要的点：
ref 如果是在dom结构中是获取dom的元素，如果放到组件中就是获取组件实例，并不是dom结构元素了。
例如父亲调用子组件的方法为：
mounted(){
    this.$refs.load.hide();//load是ref对应的值，hide是方法。
    //也可以操作整个组件，如
    this.$ref.load.$el.sytle.background='red';//整个组件背景红色
}


```


#####--vue自带标签#####
template
slot
transition
component
```
component 的使用：
<component :is="c"></component>
//这里的c表示的组件，当前的子组件。
例如：components:{home,list} //两个组件
如果c等于home，则显示home组件的内容。如果等于list则显示list组件的内容。
也就是我们可以控制c来进行组件之间的切换。


radio表单注意部分：v-model进行绑定时，如果不写value则绑定值是true或者是false。只有写了value绑定的值才是value里边的值。

```

keep-aliv

```

keep-alive 用来缓存的组件标签component的
在使用component时，如果component的is属性指向了别的组件，则之前的组件会被销毁。所以每次再点回之前的组件时，都需要重新创建那个组件，所以我们用keep-alive标签来缓存。如果缓存了就不会再走销毁创建等钩子函数了。
如：<keep-alive> 
        <component :is="com"></component>
    </keep-alive>

```



####vue-router路由####
```
    在使用路由之前是需要安装路由的
    需要安装路由为: vue-router 
    vue-router的使用时依赖于vue的，所以在使用vue-router时需要先


    如果在vue-router理由开发时用的是hasha值开发，只有在上线时才用html5中的history，因为hash，seo不认识。
    
    
    代码与分析如下：
    <body>
    <div id="app">
          <!-- 把路由页面放入到网页中 -->
        <router-view></router-view>
    </div>
    <script src="node_modules/vue/dist/vue.js"></script>
    <!-- 引入vue-router路由标签 -->
    <script src="node_modules/vue-router/dist/vue-router.js"></script>

    <script>
        //两个组件
        let home={template:"<h1>home</h1>"};   
        let list={template:"<h1>list</h1>"};  

        //组件对应的路由配置，这个叫做路由映射
        /* 必须有/，否则不能表示是路径*/
        let routes=[
            {path:"/home",component:home},
            {path:"/list",component:list}
        ];    

        //把路由映射放入到vue路由器中
        let router=new VueRouter({
            mode:"hash",
            routes
        });    

        //把路由器放入到vue中
        let vm=new Vue({
            el:"#app",
            router

        });
    </script>

</body>



    路由有两种链接模式分为为：
    mode:"hash" //默认是hash,一般开发使用
    mode:"history" //上线使用，但是在浏览器地址栏时不能按回车，按回车会报404的错误。


    路由连接：
<router-link to="/home"></router-link>
为了弥补a链接的不足，a链接只能在hash情况下能够跳转，但是在history的模式下能跳转。
代码如下：
<div id="app">
    <router-link to="/home">首页</router-link>
    <router-link to="/list">列表页</router-link>
    <!-- <a href="/home">首页</a>//history模式下不能实现跳转
    <a href="/list">列表页</a> -->
    <!-- 把路由页面放入到网页中 -->
    <router-view></router-view>
 </div>


如果我们想让<router-link>标签以button或者是其他的形式的标签显示，则需要加上tag属性即可。
<router-link tag="button">...
如果我们想让这个链接（router-link标签）在被激活时，有激活的样式类。对这个类进行样式修改就能有不一样的样式效果。
是在VueRouter中进行的默认样式的修改为：LinkActiveClass:'active' ,那么我们在style中所写的active样式就会是被激活的样式。


编程式导航，就是通过js实现页面的跳转：
每个组件中都有$router （存的是方法） 和 （存的是属性） 
this.$router.push("/list");//强制跳转路径
this.$router.back();//返回上一个链接
this.$router.go(-1);//-1表示的是返回上一个链接
this.$router.replace("/list")//替换路由路径，原来的路劲会被替换掉





路由的匹配：
默认展示的路由，就是path设置为空，如果都匹配不到则为*号表示，放在后边。
     {path:"",component:home}, //默认路由器
     {path:"/home",component:home},
     {path:"/list",component:list}
     {path:"/*",redirect:"/home"} //就是当上边都匹配不到时，重定向到home组件上边。
     



路由嵌套：
children的路径永远不带/，因为/表示的是一级路由。
    {
        path:"/list",
        component:list，
        children:[
            {path:"profile",component:profile},
            {...}
        ]
    }
    
    子路由所配的内容是嵌套在父路由里边的，也就是父路由里边会有router-link和router-view来显示子路由的组件。
    子路由的router-link标签所对应的地址是全的如:"/detail/子路由"
    子路由的组件可以和父路由一样写在外边。
    
    
    
    
    
    参数路由：
    就是我们会在用网址访问路由器的时候会带有参数，如下：
    http://localhost/home/1/b/huminggui
    在vue中的显示方式是如下：
    第一种方式：
    <router-link to="/home/1/b/huminggui"> 商品</router-link>
    第二种方式：
    这种方式有规范，当存在:to动态的to值来指定路由，并且路由带有参数的话。路由必须要用自己的名字来表示，也就是路由必须有name值。
    路由name值的设置为：{path:"/home/:c/:d/:f",component:home,name:home1},这个名字是自己取的。所以，路由的带参数的第二种方式如下:
    <router-link :to="{name:'home1',params:{c:1,d:'b',f:'huminggui'}}">商品</router-link>
    这样和路由的设置比较比配、比较直观、比较容易理解。
    
    
    那么我们的路由器是怎么匹配的呢?
    ：{path:"/home/:c/:d/:f",component:home,name:'home1'}
    :c :d :f 这个是自己设定的，并不是系统规定的，我们想怎么写都是可以的。同时在我们的组件上会产生一个对象为:{c:1,d:b,f:huminggui},这个是属性所以是挂载到$routes上的。所以如想获取传递过来的参数，用$this.$route.params.xx  xx表示要取得的值的key值。如果在组件上的template中直接使用，可以去掉this，直接写{{$route.params.xx}}
    
    ajax写在什么位置呢？
    我们不能把ajax写在created()这个钩子函数里边了，因为我们在点击链接时，dom的结构是不会变的，根据vue的原理，当dom结构不发生改变时（dom结构会有缓存），则不会对组件进行生命周期的运转。在vue中只是值在发生变化，那么就会在相同的dom结构中填写值，而不会重新走一遍组件的生命周期。
    所以我们需要用watch来监听浏览器地址栏参数的变化，参数变化时ajax的请求发生变化。如下代码：
    //地址栏参数的变化是this.$route.params的内容发生变化，那直接监控$route就可以的。
    watch:{
        $route(){
            ajax....等相关操作。
        }
        
    }
    
这个地方比较难理解，写个实例再一次进行分析：
如果是点击router-link链接，那么生命周期会执行一遍。
通过浏览器地址栏改变链接后边的参数时，则不会再执行生命周期。生命周期的执行是dom结果发生改变时才会执行的。
以下是，钩子函数和watch监听器的对比后的结果实现的。
let home={
    template:"<h1>home{{$route.params}}</h1>",
    created(){
        alert(1);
    },
    watch:{
        $route(){
            alert(2);
        }
    }
};   

当监听$route属性时，一旦地址栏参数有改变，会发生变化。
    
    
    
    
    
    
 
 
 动画和缓存:
 <keep-alive>标签是，想要缓存就用这个标签包起来。
 路由切换组件是会销毁组件的。   
 我们就是想让router-view的这个标签的内容出现动画的效果，操作方法如下：
 需要引入 animate.css这个库
 <transition 
 enter-active-class="animated fadeIn"  //这个是进来时动画
 leave-active-class="animated fadeOut"//出去时动画
 /*mode="out-in"  //先出去再进来*/这个可以不写
 >
    <keep-alive> //保持组件不被销毁，保证缓存
        <router-view style="position:absoute;top:0;left:0;width:100%;"></router-view>//为何要写样式，因为不定位的话，dom结构会有抖动，动来动去的。
    </keep-alive>
 </transition>
    
    
```

####模块####
```
规范：

node模块规范common.js
required（""）这个是后端node的模块规范，并不是前端的规范。所以在前端无法使用的。如果在前端要使用这个那么就需要引入前端的库进行规范才能够使用。


前端模块规范：
cmd  seajs amd  requirejs



es6模块规范：
esmodule
esmodule是浏览器兼容的。那么它是如何操作的呢？
定义模块（一个js就是一个模块）
导出模块（export）
使用模块（import）


umd规范
是为了兼容其他的规范而生成的，




前端规范的使用，也就是es6(esmodule)的使用：
兼容性问题，百度找兼容代码

前端的规范是html文件，如果我们引入js时需要把js当作一个模块，那么在引入时需要写:<script src="main.js" type="module"></script>
需要引入其他的js文件到main.js文件中使用的话，就要用import 
关于import的引入地址问题：
1，如果是第三方文件（node_modules文件下的文件）不需要加"./",如果是自己的文件需要加上"./"表示的是当前的路径。
2，导入的对象和接收的对象是按照解构赋值操作的，导入和接收的对象必须是等同的，不能是随便找一个变量进行接收。如下：
import {str1，str2} from  "a.js";
a.js的内容如下：
export str1="I am  A";
export str2="I am B";

但是这样接收的方式太麻烦了，所以我们有了简便的方式如下：
import * as a from "a.js"
那么a这个变量就代表着所有的返回过来的所有的内容。a接收的是导入过来的对象。


3,import有声明的功能。





export default的导出：
表示的是默认导出，并且只能导出一个。
如果是这种方式导出的内容。那么import的接收就容易的多了。
直接是：import xxx  from  "./a.js"; 


export导出 和 export default的导出之间的关系：
1，export能导出多个，多个之间自动关联成一个对象，接收则不能直接接收，接收方式为两种，一种是解构接收，一种是* as接收。
2，export default 只能导出一次，接收很简单，直接变量接收即可。





```


####webpack####
```

是一个模块加载器兼打包器，还可以压缩，图片转成base64等。支持很多语法，js，jsx，less等等。
commonjs写的，但是也支持cmd和amd。





-----下载webpack：
1,安装webpack最好不要安装全局的。否则可能会到导致webpack的版本差异。

webpack2或者3是自带的webpack-cli 



npm install webpack --dev
安装的时候需要先删除本地，然后再删除全局。再进行安装。
虽然只安装了webpack文件，但是在在node_modules文件中会看到很多的文件，除了webpack文件夹外，其他的文件都是webpack的依赖。依赖和主文件在一个目录，那是因为避免之后的插件需要同样的依赖时避免重新下载。

2,需要在当前目录下新建一个webpack.config.js的配置文件。

3，我们配置webpack。
package.json中的script所对应的key-value值都是可以在命令行执行命令的。操作方法是：npm run key; 就看配置的key是什么，用npm run key进行操作后就会执行value的文件。
对webpack我们执行的文件是 node_modules/webpack/bin/webpack.js 这个文件。
所以正常我们设置为：
script:{
    "build":"webpack"
}
设置上边的命令是到当前目录下查找webpack.config.js这个文件。
具体的命令流程是：
上边的webpack指的是node_modules下的webpack，在webpack的目录下寻找bin，在bin目录下寻找 webpack.js。而这个webpack.js的指向是在当前根据下找webpack.config.js。

在webpack.config.js中必须按照commonjs的规范编写。




    **在webpack.config.js中的设置如下：**

//专门处理路径用的一个path模块
let path=require("path");
/*path.resolve("./dist");会生成一个以当前路径为目录的绝对路径 */

//webapck.config.js必须要按照commonjs的方式编写
module.exports={
    entry:"./src/main.js",   /*打包的入口文件，会自动寻找相关的依赖自动进行打包。*/
    output:{
        filename:"bundle.js",  //这个是打包后的文件，这个文件名是我们自己定的
        path:path.resolve("./dist")  //这里必须是一个绝对路径
    }

}

通过npm run build 运行后会生成dist的文件，这个文件是根据main.js的依赖进行的打包，打包后，直接通过html文件script引用就可以使用和执行。


注意：
1,webpack不仅仅兼容commonjs还兼容esmodule以及amd、cmd等等。所以是通过其他的规范写的，再打包之后，都是可以正常运行。但是一般我们都建议用一种规范来做，这样有利于不出现规范混合的情况。
所以node下用commonjs规范，不能用esmodule规范。但是新的的node把js的文件改成mjs的话是可以支持esmodule的。
所以用webpack打包之外，还能让之前用其他规范写的模块都兼容。

2,在安装了babel之后，再运行npm run build 的时候有可能会提示找不到webpack，那么这个时候重新安装webpack就可以。






-----babel把es6转成es5 
主要是要兼容ie等其他的浏览器。
安装babel的核心包
npm install babel-core --save-dev 
安装babel的翻译器，进行编码的翻译：
npm install babel-loader --save-dev

但是我们并不是所有模块下的js文件都要进行转义的（node_modules就不需要），所以我们需要对编码转义进行规则的限制：
编码规则限制：
用的是babel-loader进行转义，排除掉node_modules。
module:{
    rules:[
        {test:/\.js$/,use:"babel-loader",exclude:/node_modules/}
    ]
}

test表示的是需要转义的以js结尾的。正则。
use表示的是用的转义方法是bable-loader
exclude表示排除的内容。正则。

通过babel-laoder 和 babel-core 两个操作之后其实并没有让es6转变成es5，因为babel-loader其实不知道该转成谁。所以我们要给babel-loader 一个标准，这个标准的插件叫做：babel-preset-es2015 。
安装成功之后，在当前目录新建一个".babelrc"（没有后缀没有名字，这个是个固定写法）  ，在这个文件里边写上如下代码：
{
    "presets": ["es2015"]
}

babel-loader会通过babelrc的文件内容来进行编译。这个是告诉babel-loader你编译成es2015。但是这个地方报错代码如下：
Error: Plugin/Preset files are not allowed to export objects, only functions.
这时因为babel-preset-es2015这个插件存在版本兼容。所以需要安装babel-preset-env  并且把.babelrc的文件名变成.browserslistrc,且内容改成如下：
{
    "presets": [
        ["@babel/preset-env"
            "targets": {
                "esmodules": true
            }
        ]
    ]
}


    兼容es7语法
安装 babel-preset-stage-0   开发模式安装
es7语法能够解析...{}  对象。
但是其实我们并不需要安装，因为babel-preset-




    样式打包：
    css打包
把样式引入到js文件中时，可以用import " ./xx.css" 不需要名字接收的。
安装css解析器：npm install    css-loader  --save-dev
安装css解析之后内容插入到style标签: 
npm install style-loader --save-dev
然后在添加规则：
但是我们安装了两个loader解析器，那么是有顺序的，顺序是先右后左，就是先执行的写在右边。css-loader先执行。所以规则如下：
{test:/\.css$/,use:["style-loader","css-loader"]}
打包成功后，因为我们是在js中引入的css样式，所以css样式会跟着js文件打包成一个文件。那么我们在页面引入这个js文件的时候，css样式也同样会对页面起到样式效果。



    less打包
    less 安装
    less-loader 安装
    css-loader 安装
    style-loader 安装  以上都是本地安装
    因为less最后是转变成css样式，所以需要安装css的打包器。
    在js文件中引入这个less文件(import "./xx.less")
然后在webpack.config.js中写匹配规则：
{test:/\.less$/,use:["style-loader","css-loader","less-loader"]}




    图片打包：
    一般指的是在css中的背景图片。
    file-loader 安装
    url-loader 安装 
    我们使用的时候，使用的是url-loader，url-loader会自动的引用file-loader。
     {test:/\.(jpg|png|gif)$/,use:"url-loader?limit=8192"},//图片,?后边是把图片做一个限制，8k以下的才能转成base64格式。因为默认就是转成base64的。否则文件太大了。（8192字节=8k）
    我们对图片的大小进行了设置后，符合条件的就会转成base64了。打包后，不符合条件的就会在和打包文件同一个目录下生成一个图片。我们引用打包文件后图片则会正常显示。
    
    
    **关于js中代码创建图片后webpack打包的坑：
    let  img =new  Image();
    img.src="./l.jpg";
    document.body.appendChild(img);
    这段代码打包后并不会显示图片。因为webpack打包后，打包文件会正常生成。但是引入这个打包文件后，执行这段代码会发现"1.jpg"是找不到的，因为打包文件的生成是另一个目录了，根本没有1.jpg这张图片。 打包文件一般是在dist目录里边。dist目录也是webpack在打包时自动生成的打包成功后的目录。 
    解决办法有两个：
    第一个是img的路径是线上路径。打包成功后，执行这段代码时，图片路径是线上路径，地址是不变的。
    第二个是用import pageImage from "./1.jpg" 的方式引入图片，然后，img.src=pageImage。因为webpack会把import导入的内容进行打包(平时导入的js文件等)，所以图片也会被打包，并且放入到dist目录下和打包文件是同一个目录。那么在打包后的文件里这段js代码是，pageImage变量的值和外边图片地址的值是相等，从而实现引用。
     {test:/\.(eot|svg|woff|woff2|wtf)$/,use:"url-loader"}  //图标后缀，但是这个文件和图片还是不一样的。



    **解析html的插件：
插件的作用：是以我们自己的html为模板，将打包后的结果自动插入到html中，并且产出到dist目录下。
npm install  html-webapck-plugin --save-dev
安装之后的使用：
在webpack.config.js中进行设置，因为我们这个是插件所以需要手动进行引入和操作。
let HtmlWebpackPlugin=require("html-webpack-plugin");
plugins:[
    new HtmlWebpackPlugin({
        template:"src/index.html" ，//表示以哪个html文件为引入文件后进行打包。
        filename:"xx.html" //产出的文件名，不写默认原始文件名
    }); //自动生成dist/index.html文件
] //和module同级

这样就可以了。
其实原理很简单，就是把打包好的文件，带上指定的html文件都到dist目录下，再把打包好的文件自动引入到带过去的html文件。这样就不需要人为去引入了。



    
    自动打包：
    webpack-dev-server  安装
    开启一个端口并且创建一个服务，监控我们的文件中的代码变化，自动进行打包，打包后的打包文件储存在内存中。
    在package.json中的script属性下边增加一个 "dev"的属性，值为："webpack-dev-server"  如下：
    "scripts": {
    "build": "webpack",
    "dev":"webpack-dev-server"
  },
  当我们运行的这个指令后，就会有一个页面一直显示着，表示一直在监听。
  运行成功后会给我们自动生成一个服务器地址，我们打开服务器地址就能过够看到我们打包后页面的效果。
如图：
```
![image_1cvpt54p562cu0q1feq15p31vdi9.png-22kB][19]

这里的默认服务器地址是http:localhost:8080
运行这个命令的底部是一直在等待的命令，如图：
![image_1cvptadtdjhrasi1ei282oa8dm.png-27.8kB][20]


####webpack与vue的关系####
```
    webpack中使用vue:
只需要在vue的html页面中有一个id为app的div就可以。
当然也是需要安装vue的。
在webpack中main.js中使用vue是用，import Vue from "Vue";es6语法是直接在node_modules中去寻找的。所以不需要写路径。
但是，import引入的vue 引入并不是vue.js这个文件，是vue的runtime文件。
vue 是compiler 和 runtime 两个组成。compiler是编译模板的。所以import这么引入Vue，则Vue是不能够编译模板的(不能用template)。如果想使用全的vue则有以下方法：
第一种：import Vue from "vue/dist/vue"  //直接写清楚引的是哪个文件
第二种：在vm中有一个render的方法，把模板写入这个方法中。如下图：
new Vue({
    render:function(createElement){
        return createElment("h1",[
            "content"，
            create....
        ]);//这个返回值的内容就会在id为app的div中显示。返回的是一个h1标签，内容为content。后面的数组是添加子标签，方法与上边一样。
    }
}).$mount("#app");
render的作用是将虚拟的dom渲染成真实的dom。
createElement返回的是虚拟的dom。

但是上边实在是太混乱了，所以为了解决这个混乱问题。vue文件就诞生了，即以.vue结尾的文件。例如：xx.vue  vue文件代表着一个组件。所以，vue文件结构为:
<template>
    <div></div>
</template>
<script>
    export default{
         data(){
            return{  //组件的data是函数
            }
        }，
        methods:{
            
        },
        computed:{
            
        },
        components:{
        }
    }
   
</script>
<style scoped>


</style> //样式是自己管自己的样式
scoped 是值样式只在当前文件使用

    打包vue文件的两个插件：
    vue-loader (只用这个就可以，会自动调用vue-template-compiler这个插件)
    vue-template-compiler  
    因为我们引入的vue没有编译功能，所以需要vue-template-compiler  
    规则：
    {test:/\.vue$/,use:"vue-loader"}

在main.js中是引入vue文件为：import xx from "./xx.vue";//自己写的组件记得加上./路径
然后我们把这个组件渲染到页面，则是刚刚的render方法，只是这一次直接把这个组件当成参数即可。
render:function(createElement){
    return createElement(xx); //zheg xx就是xx.vue
}
用createElment把一个组件渲染成虚拟dom，然后render渲染成真实dom。
我们可以把这个方法简化成箭头函数：
render:h=>h(xx);










    重点**需要注意的是：vue-loader在15版本之后需要带插件才能解析vue文件。
    如下：
    //vue-loader-plugin插件的引入
    let VueLoaderPlugin=require("vue-loader/lib/plugin");

     plugins:[
         new VueLoaderPlugin()
     ]

```

####vue的配置与组件分析####
组件分析，如图：
![image_1d01fl0o91vpb1e931ata1e398io9.png-118.5kB][21]


```
    根据上图的分析：
首先是有main.js当然是一个index.html页面。
当我们把main.js写好以后，我们就需要写app.vue这个组件了，如上图。
app.vue写好之后，引入并且渲染到main.js中，那么渲染是render:h=>h(app);
然后运行 npm run dev  这个是开启了一个端口服务，监听页面的发展变化。
根据上图，就是路由分配两个页面，我们把一个页面叫做一个组件。放入到components。页面写好之后，写路由。因为没有路由无法访问其他页面。
写好路由之后需要注册一个下路由：
Vue.use(VueRouter);
注册后这个vue的路由就是全局属性了。才能够在其他的页面使用<router-view>标签。
然后把router文件分开到另外一个文件夹。
    Vue.use()方法的实现原理：
    首先我们写一个组件：
    创建一个空对象，
    let notify={
    }
    给这个空对象添加一个install方法；
    notify.install=function(Vue,options){
        /*Vue是构造函数，options是Vue.use时除了插件本身，传递的参数。例如：Vue.options(Vue,1,2) */
        Vue.prototype.$notify=function(message,opt){
        /*$notify是我们的插件名字,我们把这个插件放到Vue的原型上。*/
            options={...options,...opt};//新的覆盖旧的
            import notifyVue from "notify.vue"
            /*引入模板，notifyVue是自己创建的vue的模板*/
            let V=Vue.extend(notifyVue);//返回一个子类
            /*V是一个子构造函数，继承的Vue的*/
            let vm =new V;
            
            /*创建出了vue，但是没有dom元素可以挂载*/
            let oDvi=document.createElement("div");
            
            /*创建dom元素并且挂载到dom元素上*/
            vm.$mount(oDiv);
            
            /*再把vm.$el放入页面上*/
             document.body.appendChild(vm.$el);
            /*多少秒后删掉这个dom元素 */
            setTimeout(function(){
                document.body.removeChild(vm.$el);
            },options.delay);
        }
        
    }
    //导出这个notify，当Vue.use(notify)时就调用这个notify下的install方法。
    export default notify;
    
    
    具体详细的代码在如下：
    import notifyVue from "./notify.vue";

let notify={

}


notify.install=function(Vue,options){
    /*把$notify的方法挂载到原型上边 */
    Vue.prototype.$notify=function(message,opt){
        options={...options,opt};

        /*子构造函数是继承Vue的*/
        let V=Vue.extend(notifyVue);

        /*生成一个子vm */
        let vm=new V;
        console.log(vm);
        /*创建一个dom元素 */
        let oDiv=document.createElement("div");
        /*把vm挂载到这个dom元素上边 */
        vm.$mount(oDiv);
        console.log(vm);
        /*dom元素添加到body里边 */
        document.body.appendChild(vm.$el);
        /*多少秒后删掉这个dom元素 */
        setTimeout(function(){
            document.body.removeChild(vm.$el);
        },options.delay);
    }
}

export default notify;






app.vue的详细代码：

<template>
    <div>
        ninhoa

        <button @click="show">
            显示弹窗3秒后关闭
        </button>
        <router-view></router-view>
    </div>

</template>

<script>
    export default{
        data(){
            return {
                
            }
        },
        methods:{
            show(){
                this.$notify();
            }
        }

    }
</script>
<style>

</style>





notify.vue的详细代码：

<template>
    <div class="notify">
        hellow
    </div>
</template>


<script>
    export default {
        data(){
            return{
            }
        },
        methods:{
        }
    }


</script>
<style spcoed>
    .notify{
        width:300px;
        height:200px;
        line-height:200px;
        text-align:center;
        position:absolute;
        left:0;right:0;top:0;bottom:0;
        margin:auto;
        background:#ddd;
        color:#fff;
    }

</style>


```

####vuecli的使用#### 
首先安装vue-cli:

```
安装vue-cli 如下：
npm install vue-cli -g
//这个vue-cli最好是全局安装，否则会有些问题。
vue init webpack 项目名字

在vue-cli中，配置文件分成打包的配置文件和正常的配置文件。
打包的配置文件在build里边，正常的配置文件在config里面。

还需要在src的下边创建两个文件夹，一个是基础组件base、一个是接口文件api。
```
#####--头部组件#####

```
    iconfont图片是阿里的图标库。
    生成iconfont图标：
    图标加入购物车，然后添加项目，然后生成css链接，链接如下：
    会生成3种类型的，其中有css链接，链接地址如下：
    //at.alicdn.com/t/font_994208_nfkacoywev.css
    这个链接在浏览器打开后，会看到css代码，其中有一个.iconfont，这个是基础样式，不管使用哪个图标都要用上这个样式。
    图标的使用：
    <i class="iconfont icon-shouye"></i>  //图标的名字是生成图标时的名字。如下图：
    
```
![image_1d06auukvmafiu8m411a5k50v9.png-6.3kB][22]

```
    
    
    在组件中使用less语言：
    <style scoped lang="less">
    </style>
    
    
    
    
    router-link确切生效：
    router-link-exact-active :这个叫做确切的生效
    router-link-active   ：这个是最先的配置成功就会生效。
    怎么使用：
     a.router-link-exact-active{
           color:red;
       }
    
    
    
    router-link 标签的样式：
    是针对router-link所对应的标签。
    
    判断是否有返回按钮？
    因为返回按钮在子组件中，所以是通过父组件传递参数来判断的。
    
    如果有返回按钮怎么返回呢？
    给按钮添加一个事件，给这个事件添加一个方法，返回的方法为：
    this.$router.go(-1)
    
    
    vue中的轮播图：
    npm install vue-awesome-swiper --save  //安装这个插件
    在main.js中家在这个插件，并且使用这个插件：
    import vueAsesomeSwiper from "vue-awesome-swiper"
    注册这个插件：
    Vue.use(vueAsesomeSwiper);
    然后我们就可以在页面上使用轮播图的插件了，使用的方法如下。
    <swiper :options="swiperOption">//这个是配置，写在data(){}数据里边的。
        <swiper-slide v-for="（slide,index) in swiperSlides" :key="index"> 
        </swiper-slide>
    </swiper>
    
    <div class="swiper-pagination" slot="pagination"> //分页器
    </div>
    
    script的参数如下：
    export default{
        name:"carousel",
        data(){
            return{
                swiperOption:{
                    autoPlay:3500,//表示自动播放
                    setWrapperSize:true，//自动适应大小
                    pagination:"swiper-pagination",//分页器
                    observeParents:true //会受到父亲的影响
                }，
                swiperSlides:[1,2,3,4,5]
            }
        }
    }
    
    还需要引入css，这个是在main.js中引入css。引入方法如下：
    import "swiper/dist/css/swiper.css"
   // 这个是作为一个基础组件，并且是需要用到的地方直接引入即可使用,所以把样式引入到main.js中。
   
   **注意：如果是公共模块则样式也是公共样式，那么就把公共样式写入到app.vue中。
    
```




#####--footer尾部组件#####
```
    flex布局常用的属性为：
    尾部组件的布局用的是flex:
    是水平还是垂直布局：
    flex-direction: row | row-reverse | column | column-reverse;
    一行放不下该如何处理：
    flex-wrap: nowrap | wrap | wrap-reverse;
    上下居中的方式:
    justify-content: flex-start | flex-end | center | space-between | space-around;
    左右居中的方式：
    align-items: flex-start | flex-end | center | baseline | stretch;
    比例：
    flex-grow：1；表示平均分配1比1；
    
    
    
```

#####--后台模拟（mock）#####

```
    轮播图的图片的数据的实现：
    用的是node搭建的后台
    http模块，url模块，fs模块
    url里边获得pathname和query，通过pathname等于多少来判断访问的是哪个接口。
    涉及到跨域的问题，当然用的node的跨域头。
    axios的请求是写在api的文件里边。
    axios.defaults.baseURL="http://localhost:3000" 设置默认的路径。
    那么以后就可以这么使用，很方便：
    那么我们直接用axios.get("/slider");//则默认会加上axios.default.baseURL
    然后我们把请求写在api接口的index.js中
    那么我们在需要请求的组件里边引入这个请求的接口，这个一般是写在钩子函数里边。
    再把数据传入到swiper组件中，在swiper组件中加如img标签。
    即可实现。
    
    
    
        node跨域头的设置：
   res.setHeader("Access-Control-Allow-Origin", "*");
   res.setHeader("Access-Control-Allow-Headers", "X-Requested-With");
   res.setHeader("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");
   res.setHeader("X-Powered-By",' 3.2.1')
   res.setHeader("Content-Type", "application/json;charset=utf-8");
    





```

#####--对书的增删改查操作#####
```
    restful方式的方式来对书进行增删该查的操作。
    api的设计规范。
    GET：读取（Read）
    POST：新建（Create）
    PUT：更新（Update）
    PATCH：更新（Update），通常是部分更新
    DELETE：删除（Delete）
    
    通过以上来判断增删改查。但是有些客户端只有get和post两种方式。所以，客户端发出的 HTTP请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。
    
    
    在node中是req.method中获取的是：
    GET POST PUT DELETE options...
    相对应的axios是：
    axios.get
    axios.post
    axios.put
    axios.delete
    
    DELETE:服务器返回的值都是为{}?;
    
    options请求：
    options一般都会自动被后台忽略，因为它并没有实际的意义
    OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能
    
    
    获取所有图书的逻辑：
    当id存在则是获取某一个本图书。当id不存在时则获取所有的图书。
    
   删除图书的逻辑：
   就是请求到后台，后台把数据删成功了，则前台同样操作把数据删除。并不是重新申请以下后台的数据，而是直接在前台已有的数据中进行删除。
   
   
   图书的详情页面的实现：
   在list.vue中点击图书可以跳转到图书的详情页面上。
   router-link插件，需要:to="{name:xxx,params:{id:${xxId}}}",需要把router-link的标签改成我们需要的标签，如：tag="li"
   组件循环是需要加 :key="index"
   详情页是覆盖在List的页面上的。
   
   技术点：this.$router.push("/home");跳转到路由器里边。
   判断一个对象是否有为空对象，的方法为：
   1，变成字符串进行判断   
   2，Object.keys(对象);变成数组是否有长度。
   
   

```






































#####--webpack中的错误#####
```
    1,在安装babel-loader和babel-core的时候会包一个错误叫做 :Error: Cannot find module '@babel/core'
```
截图如下：
![image_1cvnl1n1l118e11vl13f118gl12ge9.png-4.2kB][23]
```
解决方法：npm install @babel/core --save-dev
这个一般是babel-loader和babel-core的版本不对应导致的。


    
    2,webpack打包时，我们需要把语言转成es2015，安装了babel-preset-es2015报错时。建议安装babel-preset-env 并且把.babelrc的文件名改成.browserslistrc，在把内容改成如下：
    {
    "presets": [
        ["@babel/preset-env"
            "targets": {
                "esmodules": true
            }
        ]
    ]
}



3,webpack-server-dev 找不到了，
    一般建议重新安装 npm install 



4，Errors while compiling. Reload prevented. 
编译错误（compiling）



5,vue中router-link不跳转的问题：
如果tag="li"，但是li里边有a标签，那么点击li不会跳转。只有点击a时，触发冒泡才会生效。

```

#####--热门图书功能实现#####
```


    第一步：先写服务端，确保数据正常返回
    第二步：api，获取数据
    第三步：引用数据到组件，如果是base组件则引入父组件
    
    
    
    如何写一个base组件：
    1，创建一个vue文件
    2，在需要这个组件中的父组件中引用
    3，父组件中注册
    4，标签表示
    
    
    
    
    
    数据是放入.js文件中还是json文件中：
    当然是json文件中，因为json文件中不需要module.exports进行导出，而是直接用fs获取数据然后对数据进行增加或者修改等。而，js文件是不方便读取然后进行修改的，因为它有module.exprots关键词。写入时会被覆盖点这些内容。如果追加写入，又无法与之前的内容放入同一个对象里边。
    
    
    
    
    
    
    axios返回数据的处理：
    /*对axios返回的结果做简单化处理，返回的就不是一个promise对象而是直接的数据 */
axios.interceptors.response.use((res)=>{
    return res.data;
});


    
    
    
    
    
    
    
    
    
```


#####--loading 和 实现页面缓存 和路由的动画效果#####
```


这个是打开网页时，数据还没有完全加载进来时现实的动画。
在这个页面总共要加载的数据有两个，一个是幻灯片的数据，一个是热门图书的数据。因此我们用到个新的关于接口的知识点，为axios.all[promise1，promise2]；因为我们的幻灯片接口和热门图书接口返回的就是promise，所以可以理解为，axios.all([接口1，接口2]);
然后在网上找到一个加载动画的组件。
当数据还没有加载完时，则加载动画显示。否则加载动画组件关闭。
判断数据是否加载完毕，就看axios把所有的接口是否执行完毕了，就写在返回数据的后边，后边表示已经执行完了。






缓存的作用和实现：
我们每次路由切换的时候都要去服务器端申请数据，这个是非常影响体验，同时也给服务器端造成很大的压力。
给路由加上一个属性，这个属性是给页面加缓存的。
先给路由的页面加上一个会缓存数据的属性。
meta:{keepAlive:true}
如果去是：this.$route.meta.keepAlive 。
以上是指添加了那个属性的就会对页面进行缓存。

通过是否有true只来判断是否需要缓存：
<keep-alive>
    <router-link v-if="this.$route.meta.keepAlive"></router-link>
</keep-alive>
这个表示走缓存。
<router-link v-if="!this.$route.meta.keepAlive"></router-link>
没有缓存的就走下边。






路由的动画效果：
组件代码：
<transition name="fadeIn">
<transition>


样式代码：
  .fadeIn-enter{ /*没有进入之前的状态，如果不些进来后的状态，默认到最大指。*/
    opacity: 0;
  }
  .fadeIn-enter-alive{/*进来多长时间，用什么样的方式*/
    transition:all 0.3s linear;
  }
  .fadeIn-leave-alive{/*出去后的状态，以及时间和方式*/
    transition:all 0.3s linear;
    opacity: 0;
  }


```

#####--加载#####
```
下拉加载的思路：
    总共有两种方法实现，但是思路是一样的，具体的实现方法，会在实现之后附上相应的代码和说明。
    
    后台，
    回应一个对象，这个对象是加载多少个数据，以及是否还有数据可加载。(详细：每次加载多少个是固定的，可以写在外边。因为没有数据而是一个数组，所以用数字的slice进行截取。每次截取是在传入进来的offset值的基础上增加多少个值。如果全部加载完了，则返回不能加载了。)
    
    api接口，
    pagenation，一个参数，这个参数是告诉后台，从什么位置开始截取。
    
    前台，
    第一次加载是created函数内加载的。
    点击加载，
    每次点击后，就会执行加载函数。首先会判断是否可以加载，如果不能够加载了，那么就不会加载。加载进来的数据是累加的，然后通过累加的数据的长度，给接口传递参数。
    向下滑加载，
    ref需要用到这个属性，这个属性的目的是获取拥有这个属性的dom元素的节点。
    通过scroll滑动来执行向下滑的事件。
    元素.scrollTop  卷距离，  元素.clientWidth  ，scrollHeight元素的总高度。
    通过判断scrollTop+clientWidth+20 >scrollHeight  就执行执行数据加载的函数。
    
***难点：防抖
    也就是清除定时器，因为scroll事件时会执行很多次，所以setTimeOut进行时间的延迟。在一段时间内，生成多个setTimeout，但是每个都会把上一个清除掉，如果上一个没有执行就不会执行了。这样是为了保证性能，否则而多次执行会导致性能降低。
代码如下：
 clearTimeout(this.timer);
    this.timer=setTimeout(()=>{
        
        console.log(1);
    },30);
为什么定时器的清除操作是写在外边的，因为的是清除掉上一个定时器。




```


#####--下拉刷新#####

```
touches: 当前屏幕上所有触摸点的列表;
如果在移动端就是手指点到时里面事件变化，并且所点的位置的变化，都可通过这个对象来获取。
touchstart事件
touchmove事件
touchend 事件
e.touches[0].pageY 手指点击开始时的位置。当然手指移动的时候也是可以用这个来获取位置的。
因为往上拉与我们没有关系，所以往上拉时把touchmove事件移除掉。   


逻辑点：下拉刷新与下拉有关，和上拉是没有任何关系的，所以我们不考虑往上滑动的情况。



    下拉刷新的逻辑：
>当我们往下拉时，会刷新当前页面的数据。
>需要考虑的是手机的屏幕手指的点击事件的位置。
>向下拉就是拉之后的位置要大于之前的位置。我们只考虑向下拉，如果是向上拉则还是遵循原来的状态。
>并且拉的距离也是有限制的，不能一直往下拉，会有一个距离的限制。
>拉完之后会有一个退回去的动画
>只有当到了顶部，向下拉时才会有下拉刷新。其他的情况拉都是要排除的。
>刷新数据要把原始的数据情况，重新进行申请。否则就会导致之前存在的数据加上新数据，这样数据就变多了。
>用wathc监听数据一旦加载完毕，页面就回到顶部。
>清除数据时要做判断，证明是下来时加载的，还是不是下来加载的






    图片懒加载
图片懒加载用插件就比较简单了
>vue-lazyload github搜索这个插件，然后安装这个插件。
>在main.js中更改两张图片的地址，然后用指令指定图片就可以
具体的代码实现如下：



``

#####--发布项目#####
```

    代码切割：
    我们正常引进路由组件的方法是：
    import Home from "../components/Home.vue"
    但是这样是把所有的组件页面都打包到一个文件里边。加载的时候也是一次性加载的。所以会导致如果我们只看首页，但是其他的页面也会被加载，这会造成首页加载很慢。为了解决这个问题，我们动态加载路由；
    动态路由加载是高级语法，需要安装一个插件。vue-cli脚手架自动安装了这个插件。
    就是点开一个路由组件页面进行加载，点开一个加载一个。写法如下：
    

```







####vue-cli脚手架的安装####

```
 npm install vue-cli -g
 vue init  webpack <项目名称>
 cd 项目名称
 install init    //安装依赖
 npm install
 npm run dev
 
 
 
 

```
























































##直播##
###妙味直播课###






















#遇到的错误#

##错误本##
###vue中html和body中不挂在vue中el的app的###

##遇错问题##
###System Volume Information"文件fs无法操作？###

fs.stat在读取信息时，如果遇到"System Volume Information"这个文件，那么需要把这个文件剔除掉，这个文件叫做系统卷标信息文件。作用是还原文件时会根据这个文件进行还原，可能删除文件时会存储一些信息到这个文件里边。























---------------------------以下是图片不得删除----------------------


  [1]: http://static.zybuluo.com/huminggui6/iysrybudkaz26tfqhuegszu3/image_1cs85lemjgjt1puv1t493om1glq9.png
  [2]: http://static.zybuluo.com/huminggui6/xpfwrkufk3esrwv96cgt4uk6/image_1cs881fh41to3seevjo13ac1pv0m.png
  [3]: http://static.zybuluo.com/huminggui6/43s2a0u8h0hoppucur53mss4/2.png
  [4]: http://static.zybuluo.com/huminggui6/iny9a738mjb49x5x52d0cqcj/3.png
  [5]: http://static.zybuluo.com/huminggui6/jxsjqkx5eo807185e1ykpt1g/image_1ct71dpe113u24lq3rp1g948179.png
  [6]: http://static.zybuluo.com/huminggui6/szkn16gg1648g2vn8fzq56vv/image_1ctf9r52m1h7iehvtq14vkqt6c.png
  [7]: http://static.zybuluo.com/huminggui6/qlhupjijb1e9iew5iiegl7ee/image_1cu0pi6ub14c3mq8lr612ng1cco9.png
  [8]: http://static.zybuluo.com/huminggui6/vwc1ay88j1aa2faiw9w4mvxx/image_1cu0vkr9m66brp01j7vd4i1ep116.png
  [9]: http://static.zybuluo.com/huminggui6/npx83tiarju3rx6s33nv3sf1/image_1cu1800kvdcb4jh1oa81i3g1vgp4j.png
  [10]: http://static.zybuluo.com/huminggui6/0s7wg3g5kniwu5plzq6ay2sg/image_1cu181lcf1bqp3s41snl1bfo1kr65g.png
  [11]: http://static.zybuluo.com/huminggui6/bx5viql69d3oi6hsi8u0vf6g/image_1cu19m39u2co1r77fij1emm8s75t.png
  [12]: http://static.zybuluo.com/huminggui6/0bj70m5xl18lub38x8kr01v3/image_1cu1bv77m1pmktpts15rlj1q1h9r.png
  [13]: http://static.zybuluo.com/huminggui6/qpilqt1lipjf9vguh4on8o7p/image_1cu1br17cs0j14ee6apoirb0i91.png
  [14]: http://static.zybuluo.com/huminggui6/1k588ias6yl8q7l4n9lykr05/image_1cu1bp29e8c7vql1vdup8p134d74.png
  [15]: http://static.zybuluo.com/huminggui6/hyx8t3zjuvvmc1hnpa4emuht/image_1cu1btah48lb1b55176t13l4re9e.png
  [16]: http://static.zybuluo.com/huminggui6/ek5hlhbncrjhxnkzar3iidt3/image_1cu1c3s49i4u192ehvc174s1mha8.png
  [17]: https://www.jianshu.com/p/96327b044e85
  [18]: http://static.zybuluo.com/huminggui6/0l21shnjlbizu99k0hktafip/image_1cuj8bbib1snrlvaiuinmpsk89.png
  [19]: http://static.zybuluo.com/huminggui6/yerfzhf6n49ygcwig2uz8jrc/image_1cvpt54p562cu0q1feq15p31vdi9.png
  [20]: http://static.zybuluo.com/huminggui6/05p6hxquj7kx5w1am2momrrn/image_1cvptadtdjhrasi1ei282oa8dm.png
  [21]: http://static.zybuluo.com/huminggui6/xljek7tbraqo3p29rcmgn6fa/image_1d01fl0o91vpb1e931ata1e398io9.png
  [22]: http://static.zybuluo.com/huminggui6/guv0hat5xu84lgxfqgs7c19l/image_1d06auukvmafiu8m411a5k50v9.png
  [23]: http://static.zybuluo.com/huminggui6/ryhg7ugcghrc0cyoq79ow7lx/image_1cvnl1n1l118e11vl13f118gl12ge9.png